; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\Offi SRC_real\Offi src!\_Network\Net\Src\sock.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?GetPeerAddr@CSock@@UAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@CSock@@UAEPAV1@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSock@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCSock@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CSock@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@CSock@@UAEHGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@CSock@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@CSock@@UAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Detach@CSock@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHostAddr@CSock@@UAEJPAXPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7CSock@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??0CSock@@QAE@XZ				; CSock::CSock
PUBLIC	?Create@CSock@@UAEHGH@Z				; CSock::Create
PUBLIC	?Attach@CSock@@UAEXI@Z				; CSock::Attach
PUBLIC	?Detach@CSock@@UAEXXZ				; CSock::Detach
PUBLIC	?GetHostAddr@CSock@@UAEJPAXPAK@Z		; CSock::GetHostAddr
PUBLIC	?GetPeerAddr@CSock@@UAEKK@Z			; CSock::GetPeerAddr
PUBLIC	?Get@CSock@@UAEPAV1@I@Z				; CSock::Get
PUBLIC	??_7CSock@@6B@					; CSock::`vftable'
PUBLIC	??_GCSock@@UAEPAXI@Z				; CSock::`scalar deleting destructor'
EXTRN	??_ECSock@@UAEPAXI@Z:NEAR			; CSock::`vector deleting destructor'
EXTRN	__purecall:NEAR
;	COMDAT ??_7CSock@@6B@
; File c:\offi src_real\offi src!\_network\net\src\sock.cpp
CONST	SEGMENT
??_7CSock@@6B@ DD FLAT:??_ECSock@@UAEPAXI@Z		; CSock::`vftable'
	DD	FLAT:?Create@CSock@@UAEHGH@Z
	DD	FLAT:?Attach@CSock@@UAEXI@Z
	DD	FLAT:?Detach@CSock@@UAEXXZ
	DD	FLAT:?GetHostAddr@CSock@@UAEJPAXPAK@Z
	DD	FLAT:?GetPeerAddr@CSock@@UAEKK@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?Get@CSock@@UAEPAV1@I@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0CSock@@QAE@XZ
_TEXT	SEGMENT
??0CSock@@QAE@XZ PROC NEAR				; CSock::CSock, COMDAT
; _this$ = ecx

; 5    : {

  00000	8b c1		 mov	 eax, ecx

; 6    : 	m_hSocket	= INVALID_SOCKET;

  00002	83 c9 ff	 or	 ecx, -1
  00005	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CSock@@6B@
  0000b	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 7    : 	m_dpid	= m_dpidpeer	= DPID_UNKNOWN;

  0000e	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00011	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 8    : }

  00014	c3		 ret	 0
??0CSock@@QAE@XZ ENDP					; CSock::CSock
; Function compile flags: /Ogty
; File c:\offi src_real\offi src!\_network\net\include\sock.h
_TEXT	ENDS
;	COMDAT ?GetPeerAddr@CSock@@UAEKK@Z
_TEXT	SEGMENT
_dpid$ = 8						; size = 4
?GetPeerAddr@CSock@@UAEKK@Z PROC NEAR			; CSock::GetPeerAddr, COMDAT
; _this$ = ecx

; 37   : 	virtual	DWORD	GetPeerAddr( DPID dpid ) { return 0; }

  00000	33 c0		 xor	 eax, eax
  00002	c2 04 00	 ret	 4
?GetPeerAddr@CSock@@UAEKK@Z ENDP			; CSock::GetPeerAddr
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Get@CSock@@UAEPAV1@I@Z
_TEXT	SEGMENT
_hSocket$ = 8						; size = 4
?Get@CSock@@UAEPAV1@I@Z PROC NEAR			; CSock::Get, COMDAT
; _this$ = ecx

; 51   : inline CSock* CSock::Get( SOCKET hSocket )	{	return( m_hSocket == hSocket ? this : NULL );	}

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	56		 push	 esi
  00004	8b 74 24 08	 mov	 esi, DWORD PTR _hSocket$[esp]
  00008	33 c0		 xor	 eax, eax
  0000a	3b d6		 cmp	 edx, esi
  0000c	0f 95 c0	 setne	 al
  0000f	5e		 pop	 esi
  00010	48		 dec	 eax
  00011	23 c1		 and	 eax, ecx
  00013	c2 04 00	 ret	 4
?Get@CSock@@UAEPAV1@I@Z ENDP				; CSock::Get
_TEXT	ENDS
PUBLIC	?Clear@CSock@@QAEXXZ				; CSock::Clear
EXTRN	__imp__closesocket@4:NEAR
EXTRN	__imp__shutdown@8:NEAR
; Function compile flags: /Ogty
; File c:\offi src_real\offi src!\_network\net\src\sock.cpp
;	COMDAT ?Clear@CSock@@QAEXXZ
_TEXT	SEGMENT
?Clear@CSock@@QAEXXZ PROC NEAR				; CSock::Clear, COMDAT
; _this$ = ecx

; 49   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 50   : 	CLOSE_SOCKET( m_hSocket );

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	57		 push	 edi
  00007	83 cf ff	 or	 edi, -1
  0000a	3b c7		 cmp	 eax, edi
  0000c	74 16		 je	 SHORT $L149709
  0000e	6a 02		 push	 2
  00010	50		 push	 eax
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__shutdown@8
  00017	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
  00021	89 7e 04	 mov	 DWORD PTR [esi+4], edi
$L149709:

; 51   : 	m_dpid	= m_dpidpeer	= DPID_UNKNOWN;

  00024	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  00027	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi

; 52   : }

  0002c	c3		 ret	 0
?Clear@CSock@@QAEXXZ ENDP				; CSock::Clear
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Attach@CSock@@UAEXI@Z
_TEXT	SEGMENT
_hSocket$ = 8						; size = 4
?Attach@CSock@@UAEXI@Z PROC NEAR			; CSock::Attach, COMDAT
; _this$ = ecx

; 55   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 56   : 	Clear();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	83 f8 ff	 cmp	 eax, -1
  00009	74 1a		 je	 SHORT $L149715
  0000b	6a 02		 push	 2
  0000d	50		 push	 eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__shutdown@8
  00014	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00017	50		 push	 eax
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
  0001e	c7 46 04 ff ff
	ff ff		 mov	 DWORD PTR [esi+4], -1
$L149715:

; 57   : 	m_hSocket	= hSocket;

  00025	8b 4c 24 08	 mov	 ecx, DWORD PTR _hSocket$[esp]
  00029	c7 46 0c ff ff
	ff ff		 mov	 DWORD PTR [esi+12], -1
  00030	c7 46 08 ff ff
	ff ff		 mov	 DWORD PTR [esi+8], -1
  00037	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0003a	5e		 pop	 esi

; 58   : }

  0003b	c2 04 00	 ret	 4
?Attach@CSock@@UAEXI@Z ENDP				; CSock::Attach
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Detach@CSock@@UAEXXZ
_TEXT	SEGMENT
?Detach@CSock@@UAEXXZ PROC NEAR				; CSock::Detach, COMDAT
; _this$ = ecx

; 62   : 	m_hSocket	= INVALID_SOCKET;

  00000	83 c8 ff	 or	 eax, -1
  00003	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 63   : 	m_dpid	= m_dpidpeer	= DPID_UNKNOWN;

  00006	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00009	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 64   : }

  0000c	c3		 ret	 0
?Detach@CSock@@UAEXXZ ENDP				; CSock::Detach
_TEXT	ENDS
PUBLIC	??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@ ; `string'
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	__imp__gethostbyname@4:NEAR
EXTRN	__imp__gethostname@8:NEAR
EXTRN	_sprintf:NEAR
;	COMDAT ??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@
CONST	SEGMENT
??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@ DB '%d.%d.%d.%d', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetHostAddr@CSock@@UAEJPAXPAK@Z
_TEXT	SEGMENT
_sin$ = -276						; size = 16
_name$ = -260						; size = 255
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_lpAddr$ = 8						; size = 4
_lpdwSize$ = 12						; size = 4
?GetHostAddr@CSock@@UAEJPAXPAK@Z PROC NEAR		; CSock::GetHostAddr, COMDAT
; _this$ = ecx

; 67   : {

  00000	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	89 84 24 10 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+276], eax

; 68   : 	ASSERT( lpAddr );
; 69   : 
; 70   : 	char name[255];
; 71   : 	LPHOSTENT lphost;
; 72   : 
; 73   : 	gethostname( name, sizeof(char)*255 );

  00012	68 ff 00 00 00	 push	 255			; 000000ffH
  00017	8d 44 24 14	 lea	 eax, DWORD PTR _name$[esp+280]
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__gethostname@8

; 74   : 
; 75   : 	SOCKADDR_IN sin;
; 76   : 	ZeroMemory( &sin, sizeof(SOCKADDR_IN) );
; 77   : 
; 78   : 	sin.sin_family	= AF_INET;
; 79   : 	lphost	= gethostbyname( name );

  00022	8d 4c 24 10	 lea	 ecx, DWORD PTR _name$[esp+276]
  00026	51		 push	 ecx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__gethostbyname@4

; 80   : 
; 81   : 	if( lphost != NULL )

  0002d	85 c0		 test	 eax, eax
  0002f	74 4e		 je	 SHORT $L149660

; 82   : 		sin.sin_addr.s_addr		= ( (LPIN_ADDR)lphost->h_addr )->s_addr;

  00031	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00034	8b 02		 mov	 eax, DWORD PTR [edx]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]

; 83   : 	else
; 84   : 		return DPERR_INVALIDPARAM;
; 85   : 
; 86   : 	sprintf( (char *)lpAddr, "%d.%d.%d.%d", sin.sin_addr.s_net
; 87   : 																	, sin.sin_addr.s_host
; 88   : 																	, sin.sin_addr.s_lh
; 89   : 																	, sin.sin_addr.s_impno );

  00038	8b d0		 mov	 edx, eax
  0003a	8b c8		 mov	 ecx, eax
  0003c	c1 ea 10	 shr	 edx, 16			; 00000010H
  0003f	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00042	51		 push	 ecx
  00043	0f b6 d2	 movzx	 edx, dl
  00046	52		 push	 edx
  00047	0f b6 cc	 movzx	 ecx, ah
  0004a	0f b6 d0	 movzx	 edx, al
  0004d	51		 push	 ecx
  0004e	52		 push	 edx
  0004f	89 44 24 14	 mov	 DWORD PTR _sin$[esp+296], eax
  00053	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR _lpAddr$[esp+288]
  0005a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 _sprintf
  00065	83 c4 18	 add	 esp, 24			; 00000018H

; 90   : 	return DP_OK;

  00068	33 c0		 xor	 eax, eax

; 91   : }

  0006a	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+276]
  00071	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00076	81 c4 14 01 00
	00		 add	 esp, 276		; 00000114H
  0007c	c2 08 00	 ret	 8
$L149660:
  0007f	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+276]
  00086	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0008b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00090	81 c4 14 01 00
	00		 add	 esp, 276		; 00000114H
  00096	c2 08 00	 ret	 8
?GetHostAddr@CSock@@UAEJPAXPAK@Z ENDP			; CSock::GetHostAddr
_TEXT	ENDS
PUBLIC	??1CSock@@UAE@XZ				; CSock::~CSock
; Function compile flags: /Ogty
;	COMDAT ??1CSock@@UAE@XZ
_TEXT	SEGMENT
??1CSock@@UAE@XZ PROC NEAR				; CSock::~CSock, COMDAT
; _this$ = ecx

; 11   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 12   : 	Clear();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	57		 push	 edi
  00007	83 cf ff	 or	 edi, -1
  0000a	3b c7		 cmp	 eax, edi
  0000c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CSock@@6B@
  00012	74 16		 je	 SHORT $L149734
  00014	6a 02		 push	 2
  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__shutdown@8
  0001d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00020	50		 push	 eax
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
  00027	89 7e 04	 mov	 DWORD PTR [esi+4], edi
$L149734:
  0002a	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  0002d	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi

; 13   : }

  00032	c3		 ret	 0
??1CSock@@UAE@XZ ENDP					; CSock::~CSock
_TEXT	ENDS
EXTRN	__imp__bind@12:NEAR
EXTRN	__imp__htonl@4:NEAR
EXTRN	__imp__htons@4:NEAR
EXTRN	__imp__setsockopt@20:NEAR
EXTRN	__imp__WSASocketA@24:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Create@CSock@@UAEHGH@Z
_TEXT	SEGMENT
_lLinger$ = -28						; size = 4
_reuse$ = -24						; size = 4
_sin$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_uPort$ = 8						; size = 2
_type$ = 12						; size = 4
?Create@CSock@@UAEHGH@Z PROC NEAR			; CSock::Create, COMDAT
; _this$ = ecx

; 16   : {

  00000	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	89 44 24 1c	 mov	 DWORD PTR __$ArrayPad$[esp+32], eax

; 17   : 	SOCKADDR_IN sin;
; 18   : 
; 19   : 	Clear();

  0000f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00012	83 f8 ff	 cmp	 eax, -1
  00015	74 1a		 je	 SHORT $L149743
  00017	6a 02		 push	 2
  00019	50		 push	 eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__shutdown@8
  00020	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00023	50		 push	 eax
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
  0002a	c7 46 04 ff ff
	ff ff		 mov	 DWORD PTR [esi+4], -1
$L149743:

; 20   : 
; 21   : 	if( ( m_hSocket = WSASocket( AF_INET, type, 0, NULL, 0, WSA_FLAG_OVERLAPPED ) ) == INVALID_SOCKET )

  00031	8b 4c 24 28	 mov	 ecx, DWORD PTR _type$[esp+28]
  00035	6a 01		 push	 1
  00037	6a 00		 push	 0
  00039	6a 00		 push	 0
  0003b	6a 00		 push	 0
  0003d	51		 push	 ecx
  0003e	6a 02		 push	 2
  00040	c7 46 0c ff ff
	ff ff		 mov	 DWORD PTR [esi+12], -1
  00047	c7 46 08 ff ff
	ff ff		 mov	 DWORD PTR [esi+8], -1
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASocketA@24
  00054	83 f8 ff	 cmp	 eax, -1
  00057	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0005a	75 12		 jne	 SHORT $L149623

; 22   : 	{
; 23   : 		TRACE( "Can't create socket with error %d\n", WSAGetLastError() );
; 24   : 		return FALSE;

  0005c	33 c0		 xor	 eax, eax
  0005e	5e		 pop	 esi

; 40   : 	{
; 41   : 		TRACE( "Can't bind socket with error %d\n", WSAGetLastError() );
; 42   : 		return FALSE;
; 43   : 	}
; 44   : 
; 45   : 	return TRUE;
; 46   : }

  0005f	8b 4c 24 18	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+28]
  00063	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00068	83 c4 1c	 add	 esp, 28			; 0000001cH
  0006b	c2 08 00	 ret	 8
$L149623:
  0006e	57		 push	 edi

; 25   : 	}
; 26   : 
; 27   : 	int reuse	= 1;
; 28   : 	setsockopt( m_hSocket, SOL_SOCKET,SO_REUSEADDR, (char FAR*)&reuse, sizeof(int) );

  0006f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__setsockopt@20
  00075	6a 04		 push	 4
  00077	8d 54 24 10	 lea	 edx, DWORD PTR _reuse$[esp+40]
  0007b	52		 push	 edx
  0007c	6a 04		 push	 4
  0007e	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00083	50		 push	 eax
  00084	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR _reuse$[esp+56], 1
  0008c	ff d7		 call	 edi

; 29   : 	
; 30   : 	LINGER lLinger;
; 31   : 	lLinger.l_onoff		= 0;
; 32   : 	lLinger.l_linger	= 0;
; 33   : 	setsockopt( m_hSocket, SOL_SOCKET, SO_LINGER, (const char *)&lLinger, sizeof(LINGER) );

  0008e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00091	6a 04		 push	 4
  00093	8d 44 24 0c	 lea	 eax, DWORD PTR _lLinger$[esp+40]
  00097	50		 push	 eax
  00098	68 80 00 00 00	 push	 128			; 00000080H
  0009d	68 ff ff 00 00	 push	 65535			; 0000ffffH
  000a2	51		 push	 ecx
  000a3	66 c7 44 24 1c
	00 00		 mov	 WORD PTR _lLinger$[esp+56], 0
  000aa	66 c7 44 24 1e
	00 00		 mov	 WORD PTR _lLinger$[esp+58], 0
  000b1	ff d7		 call	 edi

; 34   : 
; 35   : 	sin.sin_family	= PF_INET;
; 36   : 	sin.sin_addr.s_addr		= htonl( INADDR_ANY );

  000b3	6a 00		 push	 0
  000b5	66 c7 44 24 14
	02 00		 mov	 WORD PTR _sin$[esp+40], 2
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htonl@4

; 37   : 	sin.sin_port	= htons( uPort );

  000c2	8b 54 24 28	 mov	 edx, DWORD PTR _uPort$[esp+32]
  000c6	52		 push	 edx
  000c7	89 44 24 18	 mov	 DWORD PTR _sin$[esp+44], eax
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htons@4

; 38   : 
; 39   : 	if( bind( m_hSocket, (LPSOCKADDR) &sin, sizeof(sin) ) == SOCKET_ERROR )

  000d1	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000d4	66 89 44 24 12	 mov	 WORD PTR _sin$[esp+38], ax
  000d9	6a 10		 push	 16			; 00000010H
  000db	8d 44 24 14	 lea	 eax, DWORD PTR _sin$[esp+40]
  000df	50		 push	 eax
  000e0	51		 push	 ecx
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__bind@12

; 40   : 	{
; 41   : 		TRACE( "Can't bind socket with error %d\n", WSAGetLastError() );
; 42   : 		return FALSE;
; 43   : 	}
; 44   : 
; 45   : 	return TRUE;
; 46   : }

  000e7	8b 4c 24 20	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+36]
  000eb	33 d2		 xor	 edx, edx
  000ed	83 f8 ff	 cmp	 eax, -1
  000f0	0f 95 c2	 setne	 dl
  000f3	5f		 pop	 edi
  000f4	5e		 pop	 esi
  000f5	8b c2		 mov	 eax, edx
  000f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fc	83 c4 1c	 add	 esp, 28			; 0000001cH
  000ff	c2 08 00	 ret	 8
?Create@CSock@@UAEHGH@Z ENDP				; CSock::Create
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogty
;	COMDAT ??_GCSock@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCSock@@UAEPAXI@Z PROC NEAR				; CSock::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	83 f8 ff	 cmp	 eax, -1
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CSock@@6B@
  0000f	74 1a		 je	 SHORT $L149756
  00011	6a 02		 push	 2
  00013	50		 push	 eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__shutdown@8
  0001a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001d	50		 push	 eax
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
  00024	c7 46 04 ff ff
	ff ff		 mov	 DWORD PTR [esi+4], -1
$L149756:
  0002b	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  00030	c7 46 0c ff ff
	ff ff		 mov	 DWORD PTR [esi+12], -1
  00037	c7 46 08 ff ff
	ff ff		 mov	 DWORD PTR [esi+8], -1
  0003e	74 09		 je	 SHORT $L149758
  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00046	83 c4 04	 add	 esp, 4
$L149758:
  00049	8b c6		 mov	 eax, esi
  0004b	5e		 pop	 esi
  0004c	c2 04 00	 ret	 4
??_GCSock@@UAEPAXI@Z ENDP				; CSock::`scalar deleting destructor'
_TEXT	ENDS
END
