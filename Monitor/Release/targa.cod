; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\Offi SRC_real\Offi src!\_Common\targa.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MAKCNCEN@CTarga?3?3Load?5Failed?5?$DN?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@DLNPHJME@Out?5of?5memory?5for?5palette?4?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@NDPBCKEG@Unknown?5TGA?5image?5type?4?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@FGOPIHLE@R?3?5?$CFd?5G?3?5?$CFd?5B?3?5?$CFd?5ALPHA?5?3?5?$CFd?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@GOLGOKGK@left?5?3?5?$CFd?5right?5?3?5?$CFd?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@JEFBGOJP@8bit?5disable?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??0CTarga@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CTarga@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeBuffer@CTarga@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Load@CTarga@@QAEHPBDPAPAEPAUtagSIZE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DecodeBitmap@CTarga@@AAEHPAE0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPalette@CTarga@@AAEHPAUtagRGBQUAD@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetRGBAPixel@@YAXPAKEEEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoDecode@CTarga@@AAEXPAPAKPAHPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?readTgaHeader@CTarga@@AAEXPAU_TgaHeader@@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?readPalette@CTarga@@AAEXHHHPAPAKHPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setGrayPalette@CTarga@@AAEXPAPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?readImage@CTarga@@AAEXPAU_TgaHeader@@PAPAKHPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?readData@CTarga@@AAEXPAU_TgaHeader@@_NPAKHPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?expandUncompressedLine@CTarga@@AAEXPAEH_NHPADPAKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?expandCompressedLine@CTarga@@AAEXPAEH_NHPADPAKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?readPixel32@CTarga@@AAEKHPADPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?readPixel8@CTarga@@AAEEHPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Read@CFileIO@@UAEIPAXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLength@CFileIO@@UAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Handle@CFileIO@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFileIO@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CFileIO@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCFileIO@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Flush@CFileIO@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetC@CFileIO@@UAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetW@CFileIO@@UAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDW@CFileIO@@UAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Tell@CFileIO@@UAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Seek@CFileIO@@UAEHJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFileIO@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?g_pTgaData@@3PADA				; g_pTgaData
_BSS	SEGMENT
?g_pTgaData@@3PADA DD 01H DUP (?)			; g_pTgaData
_BSS	ENDS
PUBLIC	??0CTarga@@QAE@XZ				; CTarga::CTarga
; Function compile flags: /Ogty
; File c:\offi src_real\offi src!\_common\targa.cpp
;	COMDAT ??0CTarga@@QAE@XZ
_TEXT	SEGMENT
??0CTarga@@QAE@XZ PROC NEAR				; CTarga::CTarga, COMDAT
; _this$ = ecx

; 9    : {

  00000	8b c1		 mov	 eax, ecx

; 10   : 	m_pBuf = NULL;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 11   : 	m_nTgaDataIdx = 0; 

  00007	89 48 2c	 mov	 DWORD PTR [eax+44], ecx

; 12   : 	m_nReadPixelCount = 0;

  0000a	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 13   : 	m_pData = NULL;

  0000d	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 14   : }

  00010	c3		 ret	 0
??0CTarga@@QAE@XZ ENDP					; CTarga::CTarga
_TEXT	ENDS
PUBLIC	??1CTarga@@QAE@XZ				; CTarga::~CTarga
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogty
;	COMDAT ??1CTarga@@QAE@XZ
_TEXT	SEGMENT
??1CTarga@@QAE@XZ PROC NEAR				; CTarga::~CTarga, COMDAT
; _this$ = ecx

; 17   : 	if(m_pBuf) safe_delete( m_pBuf );

  00000	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00003	85 c0		 test	 eax, eax
  00005	74 07		 je	 SHORT $L147933
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000d	59		 pop	 ecx
$L147933:

; 18   : }

  0000e	c3		 ret	 0
??1CTarga@@QAE@XZ ENDP					; CTarga::~CTarga
_TEXT	ENDS
PUBLIC	?FreeBuffer@CTarga@@QAEXXZ			; CTarga::FreeBuffer
; Function compile flags: /Ogty
;	COMDAT ?FreeBuffer@CTarga@@QAEXXZ
_TEXT	SEGMENT
?FreeBuffer@CTarga@@QAEXXZ PROC NEAR			; CTarga::FreeBuffer, COMDAT
; _this$ = ecx

; 20   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 21   : 	ASSERT(m_pBuf);
; 22   : 	safe_delete( m_pBuf ); 

  00003	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 23   : 	m_pBuf = NULL;

  0000c	33 c0		 xor	 eax, eax
  0000e	83 c4 04	 add	 esp, 4
  00011	89 46 24	 mov	 DWORD PTR [esi+36], eax

; 24   : 	m_pData = NULL;

  00014	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00017	5e		 pop	 esi

; 25   : }

  00018	c3		 ret	 0
?FreeBuffer@CTarga@@QAEXXZ ENDP				; CTarga::FreeBuffer
_TEXT	ENDS
PUBLIC	?DecodeBitmap@CTarga@@AAEHPAE0H@Z		; CTarga::DecodeBitmap
; Function compile flags: /Ogty
;	COMDAT ?DecodeBitmap@CTarga@@AAEHPAE0H@Z
_TEXT	SEGMENT
_pDst$ = 8						; size = 4
_pSrc$ = 12						; size = 4
_nAlign$ = 16						; size = 4
?DecodeBitmap@CTarga@@AAEHPAE0H@Z PROC NEAR		; CTarga::DecodeBitmap, COMDAT
; _this$ = ecx

; 99   : 	/*
; 100  : 	int nWidthCnt, nHeightCnt, nAlignCnt;
; 101  : 	BYTE arcCnt, imageCode;
; 102  : 
; 103  : 	if(nAlign % 2) nAlign--;
; 104  : 
; 105  : 	for(nHeightCnt = GetHeight(); nHeightCnt; nHeightCnt--) 
; 106  : 	{
; 107  : 		for(nWidthCnt = GetWidth() - nAlign; nWidthCnt > 0;) 
; 108  : 		{
; 109  : 			arcCnt = *pSrc++;
; 110  :  			if((arcCnt & 0xc0) != 0xc0)
; 111  : 			{
; 112  : 				*pDst++ = arcCnt;
; 113  : 				nWidthCnt--;
; 114  : 			}
; 115  : 		  else
; 116  : 			{
; 117  : 		    arcCnt &= 0x3f;
; 118  : 		    imageCode = *pSrc++;
; 119  : 				nWidthCnt -= arcCnt;
; 120  : 			  while(arcCnt--)
; 121  : 					*pDst++ = imageCode;
; 122  : 			}
; 123  : 		}
; 124  : 		memset(pDst,0,nAlign);
; 125  : 	}
; 126  : 	*/
; 127  : 	return 1;

  00000	b8 01 00 00 00	 mov	 eax, 1

; 128  : }

  00005	c2 0c 00	 ret	 12			; 0000000cH
?DecodeBitmap@CTarga@@AAEHPAE0H@Z ENDP			; CTarga::DecodeBitmap
_TEXT	ENDS
PUBLIC	?GetPalette@CTarga@@AAEHPAUtagRGBQUAD@@@Z	; CTarga::GetPalette
; Function compile flags: /Ogty
;	COMDAT ?GetPalette@CTarga@@AAEHPAUtagRGBQUAD@@@Z
_TEXT	SEGMENT
_prgbquad$ = 8						; size = 4
?GetPalette@CTarga@@AAEHPAUtagRGBQUAD@@@Z PROC NEAR	; CTarga::GetPalette, COMDAT
; _this$ = ecx

; 131  : 	LPBYTE buf 
; 132  : 		= &m_pBuf[m_nFileSize-768];

  00000	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00003	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  00006	8d 84 08 00 fd
	ff ff		 lea	 eax, DWORD PTR [eax+ecx-768]
  0000d	8d 48 02	 lea	 ecx, DWORD PTR [eax+2]
  00010	8b 44 24 04	 mov	 eax, DWORD PTR _prgbquad$[esp-4]
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	40		 inc	 eax
  00017	be 00 01 00 00	 mov	 esi, 256		; 00000100H
  0001c	32 d2		 xor	 dl, dl
  0001e	8b ff		 npad	 2
$L147976:

; 133  : 	for(int i=0; i<256; i++)
; 134  : 	{
; 135  : 		prgbquad[i].rgbRed      = (buf[3*i]);

  00020	8a 59 fe	 mov	 bl, BYTE PTR [ecx-2]
  00023	88 58 01	 mov	 BYTE PTR [eax+1], bl

; 136  : 		prgbquad[i].rgbGreen    = (buf[3*i+1]);

  00026	8a 59 ff	 mov	 bl, BYTE PTR [ecx-1]
  00029	88 18		 mov	 BYTE PTR [eax], bl

; 137  : 		prgbquad[i].rgbBlue     = (buf[3*i+2]);

  0002b	8a 19		 mov	 bl, BYTE PTR [ecx]
  0002d	88 58 ff	 mov	 BYTE PTR [eax-1], bl

; 138  : 		prgbquad[i].rgbReserved = 0;

  00030	88 50 02	 mov	 BYTE PTR [eax+2], dl
  00033	83 c1 03	 add	 ecx, 3
  00036	83 c0 04	 add	 eax, 4
  00039	4e		 dec	 esi
  0003a	75 e4		 jne	 SHORT $L147976
  0003c	5e		 pop	 esi

; 139  : 	}
; 140  : 	return TRUE;

  0003d	b8 01 00 00 00	 mov	 eax, 1
  00042	5b		 pop	 ebx

; 141  : }

  00043	c2 04 00	 ret	 4
?GetPalette@CTarga@@AAEHPAUtagRGBQUAD@@@Z ENDP		; CTarga::GetPalette
_TEXT	ENDS
PUBLIC	?SetRGBAPixel@@YAXPAKEEEE@Z			; SetRGBAPixel
; Function compile flags: /Ogty
;	COMDAT ?SetRGBAPixel@@YAXPAKEEEE@Z
_TEXT	SEGMENT
_pPixel$ = 8						; size = 4
_r$ = 12						; size = 1
_g$ = 16						; size = 1
_b$ = 20						; size = 1
_a$ = 24						; size = 1
?SetRGBAPixel@@YAXPAKEEEE@Z PROC NEAR			; SetRGBAPixel, COMDAT

; 158  :   ((UCHAR *)pPixel)[RGBA_RED] = r;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pPixel$[esp-4]
  00004	8a 4c 24 08	 mov	 cl, BYTE PTR _r$[esp-4]

; 159  :   ((UCHAR *)pPixel)[RGBA_GREEN] = g;

  00008	8a 54 24 0c	 mov	 dl, BYTE PTR _g$[esp-4]
  0000c	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 160  :   ((UCHAR *)pPixel)[RGBA_BLUE] = b;

  0000f	8a 4c 24 10	 mov	 cl, BYTE PTR _b$[esp-4]
  00013	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 161  :   ((UCHAR *)pPixel)[RGBA_ALPHA] = a;

  00016	8a 54 24 14	 mov	 dl, BYTE PTR _a$[esp-4]
  0001a	88 08		 mov	 BYTE PTR [eax], cl
  0001c	88 50 03	 mov	 BYTE PTR [eax+3], dl

; 162  : }

  0001f	c3		 ret	 0
?SetRGBAPixel@@YAXPAKEEEE@Z ENDP			; SetRGBAPixel
_TEXT	ENDS
PUBLIC	?readTgaHeader@CTarga@@AAEXPAU_TgaHeader@@PAD@Z	; CTarga::readTgaHeader
; Function compile flags: /Ogty
;	COMDAT ?readTgaHeader@CTarga@@AAEXPAU_TgaHeader@@PAD@Z
_TEXT	SEGMENT
_m_header$ = 8						; size = 4
_pDataSrc$ = 12						; size = 4
?readTgaHeader@CTarga@@AAEXPAU_TgaHeader@@PAD@Z PROC NEAR ; CTarga::readTgaHeader, COMDAT
; _this$ = ecx

; 195  :   // Read the TGA header (Version 1.0 and 2.0).
; 196  : 	memset( m_header, 0x00, sizeof(TGAHEADER) );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _m_header$[esp-4]
  00004	33 d2		 xor	 edx, edx
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	8b f0		 mov	 esi, eax
  0000a	89 16		 mov	 DWORD PTR [esi], edx
  0000c	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0000f	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00012	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00015	89 56 10	 mov	 DWORD PTR [esi+16], edx
  00018	89 56 14	 mov	 DWORD PTR [esi+20], edx
  0001b	89 56 18	 mov	 DWORD PTR [esi+24], edx
  0001e	66 89 56 1c	 mov	 WORD PTR [esi+28], dx

; 197  :   m_header->IdLength      = *(pDataSrc + m_nTgaDataIdx); m_nTgaDataIdx+=sizeof(char);

  00022	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00025	8b 74 24 10	 mov	 esi, DWORD PTR _pDataSrc$[esp+4]
  00029	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  0002c	88 10		 mov	 BYTE PTR [eax], dl
  0002e	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00031	42		 inc	 edx
  00032	89 51 2c	 mov	 DWORD PTR [ecx+44], edx
  00035	57		 push	 edi
  00036	8b fa		 mov	 edi, edx

; 198  :   m_header->CmapType      = *(pDataSrc + m_nTgaDataIdx); m_nTgaDataIdx+=sizeof(char);

  00038	8a 14 37	 mov	 dl, BYTE PTR [edi+esi]
  0003b	88 50 01	 mov	 BYTE PTR [eax+1], dl
  0003e	8b 69 2c	 mov	 ebp, DWORD PTR [ecx+44]
  00041	45		 inc	 ebp
  00042	89 69 2c	 mov	 DWORD PTR [ecx+44], ebp
  00045	8b fd		 mov	 edi, ebp

; 199  :   m_header->ImageType     = *(pDataSrc + m_nTgaDataIdx); m_nTgaDataIdx+=sizeof(char);

  00047	8a 14 37	 mov	 dl, BYTE PTR [edi+esi]
  0004a	88 50 02	 mov	 BYTE PTR [eax+2], dl
  0004d	8b 79 2c	 mov	 edi, DWORD PTR [ecx+44]
  00050	47		 inc	 edi
  00051	89 79 2c	 mov	 DWORD PTR [ecx+44], edi
  00054	8b d7		 mov	 edx, edi

; 200  :   m_header->CmapIndex     = *(WORD *)(pDataSrc + m_nTgaDataIdx); m_nTgaDataIdx+=sizeof(short);

  00056	0f b7 14 32	 movzx	 edx, WORD PTR [edx+esi]
  0005a	89 50 03	 mov	 DWORD PTR [eax+3], edx
  0005d	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00060	bf 02 00 00 00	 mov	 edi, 2
  00065	03 d7		 add	 edx, edi
  00067	89 51 2c	 mov	 DWORD PTR [ecx+44], edx

; 201  :   m_header->CmapLength    = *(WORD *)(pDataSrc + m_nTgaDataIdx); m_nTgaDataIdx+=sizeof(short);

  0006a	0f b7 14 32	 movzx	 edx, WORD PTR [edx+esi]
  0006e	89 50 07	 mov	 DWORD PTR [eax+7], edx
  00071	8b 69 2c	 mov	 ebp, DWORD PTR [ecx+44]
  00074	03 ef		 add	 ebp, edi
  00076	89 69 2c	 mov	 DWORD PTR [ecx+44], ebp

; 202  :   m_header->CmapEntrySize = *(pDataSrc + m_nTgaDataIdx); m_nTgaDataIdx+=sizeof(char);

  00079	8a 14 2e	 mov	 dl, BYTE PTR [esi+ebp]
  0007c	88 50 0b	 mov	 BYTE PTR [eax+11], dl
  0007f	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00082	42		 inc	 edx
  00083	89 51 2c	 mov	 DWORD PTR [ecx+44], edx

; 203  :   m_header->X_Origin      = *(WORD *)(pDataSrc + m_nTgaDataIdx); m_nTgaDataIdx+=sizeof(short);

  00086	0f b7 14 32	 movzx	 edx, WORD PTR [edx+esi]
  0008a	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0008d	8b 69 2c	 mov	 ebp, DWORD PTR [ecx+44]
  00090	03 ef		 add	 ebp, edi
  00092	89 69 2c	 mov	 DWORD PTR [ecx+44], ebp
  00095	8b d5		 mov	 edx, ebp

; 204  :   m_header->Y_Origin      = *(WORD *)(pDataSrc + m_nTgaDataIdx); m_nTgaDataIdx+=sizeof(short);

  00097	0f b7 14 32	 movzx	 edx, WORD PTR [edx+esi]
  0009b	89 50 10	 mov	 DWORD PTR [eax+16], edx
  0009e	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  000a1	03 d7		 add	 edx, edi
  000a3	89 51 2c	 mov	 DWORD PTR [ecx+44], edx

; 205  :   m_header->ImageWidth    = *(WORD *)(pDataSrc + m_nTgaDataIdx); m_nTgaDataIdx+=sizeof(short);

  000a6	0f b7 14 32	 movzx	 edx, WORD PTR [edx+esi]
  000aa	89 50 14	 mov	 DWORD PTR [eax+20], edx
  000ad	8b 69 2c	 mov	 ebp, DWORD PTR [ecx+44]
  000b0	03 ef		 add	 ebp, edi
  000b2	89 69 2c	 mov	 DWORD PTR [ecx+44], ebp
  000b5	8b d5		 mov	 edx, ebp

; 206  :   m_header->ImageHeight   = *(WORD *)(pDataSrc + m_nTgaDataIdx); m_nTgaDataIdx+=sizeof(short);

  000b7	0f b7 14 32	 movzx	 edx, WORD PTR [edx+esi]
  000bb	89 50 18	 mov	 DWORD PTR [eax+24], edx
  000be	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  000c1	03 d7		 add	 edx, edi
  000c3	89 51 2c	 mov	 DWORD PTR [ecx+44], edx
  000c6	8b fa		 mov	 edi, edx

; 207  :   m_header->PixelDepth    = *(pDataSrc + m_nTgaDataIdx); m_nTgaDataIdx+=sizeof(char);

  000c8	8a 14 37	 mov	 dl, BYTE PTR [edi+esi]
  000cb	88 50 1c	 mov	 BYTE PTR [eax+28], dl
  000ce	8b 69 2c	 mov	 ebp, DWORD PTR [ecx+44]
  000d1	45		 inc	 ebp
  000d2	89 69 2c	 mov	 DWORD PTR [ecx+44], ebp
  000d5	8b fd		 mov	 edi, ebp

; 208  :   m_header->ImagDesc      = *(pDataSrc + m_nTgaDataIdx); m_nTgaDataIdx+=sizeof(char);

  000d7	8a 14 37	 mov	 dl, BYTE PTR [edi+esi]
  000da	88 50 1d	 mov	 BYTE PTR [eax+29], dl
  000dd	8b 79 2c	 mov	 edi, DWORD PTR [ecx+44]
  000e0	47		 inc	 edi
  000e1	89 79 2c	 mov	 DWORD PTR [ecx+44], edi

; 209  : 
; 210  :   // Skip image ID
; 211  : 	m_nTgaDataIdx+=m_header->IdLength;

  000e4	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  000e7	8b d7		 mov	 edx, edi
  000e9	5f		 pop	 edi
  000ea	03 c2		 add	 eax, edx
  000ec	5e		 pop	 esi
  000ed	89 41 2c	 mov	 DWORD PTR [ecx+44], eax
  000f0	5d		 pop	 ebp

; 212  : }

  000f1	c2 08 00	 ret	 8
?readTgaHeader@CTarga@@AAEXPAU_TgaHeader@@PAD@Z ENDP	; CTarga::readTgaHeader
_TEXT	ENDS
PUBLIC	?setGrayPalette@CTarga@@AAEXPAPAK@Z		; CTarga::setGrayPalette
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
; Function compile flags: /Ogty
;	COMDAT ?setGrayPalette@CTarga@@AAEXPAPAK@Z
_TEXT	SEGMENT
_ppPal$ = 8						; size = 4
?setGrayPalette@CTarga@@AAEXPAPAK@Z PROC NEAR		; CTarga::setGrayPalette, COMDAT
; _this$ = ecx

; 232  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 233  :   int i;
; 234  :   *ppPal = new DWORD [256];

  00003	68 00 04 00 00	 push	 1024			; 00000400H
  00008	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0000d	8b 7c 24 14	 mov	 edi, DWORD PTR _ppPal$[esp+12]
  00011	83 c4 04	 add	 esp, 4
  00014	89 07		 mov	 DWORD PTR [edi], eax

; 235  :   for (i=0; i<256; i++)

  00016	33 c0		 xor	 eax, eax
  00018	b3 ff		 mov	 bl, 255			; 000000ffH
  0001a	8d 9b 00 00 00
	00		 npad	 6
$L148057:
  00020	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00022	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00029	03 ce		 add	 ecx, esi

; 236  :   {
; 237  :     SetRGBAPixel ((*ppPal)+i, i, i, i, 0xFF);

  0002b	88 41 02	 mov	 BYTE PTR [ecx+2], al
  0002e	88 41 01	 mov	 BYTE PTR [ecx+1], al
  00031	88 01		 mov	 BYTE PTR [ecx], al
  00033	88 59 03	 mov	 BYTE PTR [ecx+3], bl
  00036	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00038	8d 4c 31 04	 lea	 ecx, DWORD PTR [ecx+esi+4]
  0003c	8a d0		 mov	 dl, al
  0003e	fe c2		 inc	 dl
  00040	88 51 02	 mov	 BYTE PTR [ecx+2], dl
  00043	88 51 01	 mov	 BYTE PTR [ecx+1], dl
  00046	88 11		 mov	 BYTE PTR [ecx], dl
  00048	88 59 03	 mov	 BYTE PTR [ecx+3], bl
  0004b	8b 17		 mov	 edx, DWORD PTR [edi]
  0004d	83 c6 0c	 add	 esi, 12			; 0000000cH
  00050	8d 4c 16 fc	 lea	 ecx, DWORD PTR [esi+edx-4]
  00054	8a d0		 mov	 dl, al
  00056	80 c2 02	 add	 dl, 2
  00059	88 51 02	 mov	 BYTE PTR [ecx+2], dl
  0005c	88 51 01	 mov	 BYTE PTR [ecx+1], dl
  0005f	88 11		 mov	 BYTE PTR [ecx], dl
  00061	88 59 03	 mov	 BYTE PTR [ecx+3], bl
  00064	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00066	03 ce		 add	 ecx, esi
  00068	8a d0		 mov	 dl, al
  0006a	80 c2 03	 add	 dl, 3
  0006d	83 c0 04	 add	 eax, 4
  00070	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00075	88 51 02	 mov	 BYTE PTR [ecx+2], dl
  00078	88 51 01	 mov	 BYTE PTR [ecx+1], dl
  0007b	88 11		 mov	 BYTE PTR [ecx], dl
  0007d	88 59 03	 mov	 BYTE PTR [ecx+3], bl
  00080	7c 9e		 jl	 SHORT $L148057
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx

; 238  :   }
; 239  : }

  00085	c2 04 00	 ret	 4
?setGrayPalette@CTarga@@AAEXPAPAK@Z ENDP		; CTarga::setGrayPalette
_TEXT	ENDS
PUBLIC	?readPixel32@CTarga@@AAEKHPADPAK@Z		; CTarga::readPixel32
PUBLIC	??_C@_0BO@FGOPIHLE@R?3?5?$CFd?5G?3?5?$CFd?5B?3?5?$CFd?5ALPHA?5?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@GOLGOKGK@left?5?3?5?$CFd?5right?5?3?5?$CFd?6?$AA@ ; `string'
EXTRN	_printf:NEAR
;	COMDAT ??_C@_0BO@FGOPIHLE@R?3?5?$CFd?5G?3?5?$CFd?5B?3?5?$CFd?5ALPHA?5?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BO@FGOPIHLE@R?3?5?$CFd?5G?3?5?$CFd?5B?3?5?$CFd?5ALPHA?5?3?5?$CFd?6?$AA@ DB 'R'
	DB	': %d G: %d B: %d ALPHA : %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GOLGOKGK@left?5?3?5?$CFd?5right?5?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BG@GOLGOKGK@left?5?3?5?$CFd?5right?5?3?5?$CFd?6?$AA@ DB 'left : %d'
	DB	' right : %d', 0aH, 00H			; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?readPixel32@CTarga@@AAEKHPADPAK@Z
_TEXT	SEGMENT
_pCurEntry$ = 8						; size = 4
_bpp$ = 8						; size = 4
_Dest$ = 12						; size = 4
_pDataSrc$ = 12						; size = 4
_pPal$ = 16						; size = 4
?readPixel32@CTarga@@AAEKHPADPAK@Z PROC NEAR		; CTarga::readPixel32, COMDAT
; _this$ = ecx

; 389  :   DWORD Dest;
; 390  :   WORD Src;
; 391  :   UCHAR pCurEntry[4];
; 392  : 	int						i;
; 393  : 
; 394  :   switch (bpp)

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _bpp$[esp-4]
  00004	8d 42 f8	 lea	 eax, DWORD PTR [edx-8]
  00007	83 f8 18	 cmp	 eax, 24			; 00000018H
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	0f 87 77 01 00
	00		 ja	 $L148339
  00013	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $L148338[eax]
  0001a	53		 push	 ebx
  0001b	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L148342[eax*4]
$L148190:

; 395  :   {
; 396  :     case 8:
; 397  :       Dest = pPal[*(pDataSrc + m_nTgaDataIdx)];

  00022	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00025	8b 4c 24 10	 mov	 ecx, DWORD PTR _pDataSrc$[esp+4]
  00029	0f be 14 08	 movsx	 edx, BYTE PTR [eax+ecx]
  0002d	8b 4c 24 14	 mov	 ecx, DWORD PTR _pPal$[esp+4]
  00031	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]

; 398  : 			m_nTgaDataIdx+=sizeof(char);

  00034	40		 inc	 eax
  00035	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  00038	5b		 pop	 ebx
  00039	89 54 24 0c	 mov	 DWORD PTR _Dest$[esp], edx

; 438  :       break;
; 439  :   }
; 440  :   return Dest;

  0003d	8b c2		 mov	 eax, edx
  0003f	5e		 pop	 esi

; 441  : }

  00040	c2 0c 00	 ret	 12			; 0000000cH
$L148192:

; 399  :       break;
; 400  :     case 15:
; 401  :     case 16:
; 402  :       Src = *(WORD *)(pDataSrc + m_nTgaDataIdx); m_nTgaDataIdx+=sizeof(short);

  00043	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  00046	8b 44 24 10	 mov	 eax, DWORD PTR _pDataSrc$[esp+4]
  0004a	0f b7 04 01	 movzx	 eax, WORD PTR [ecx+eax]
  0004e	83 c1 02	 add	 ecx, 2
  00051	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx

; 403  :       if (bpp == 16)

  00054	83 fa 10	 cmp	 edx, 16			; 00000010H

; 404  :         SetRGBAPixel (&Dest,
; 405  :                       (UCHAR)(((Src >> 10) & 31)*8),
; 406  :                       (UCHAR)(((Src >> 5) & 31)*8),
; 407  :                       (UCHAR)((Src & 31)*8),
; 408  :                       (UCHAR)(Src & 32786 >> 8));

  00057	8b c8		 mov	 ecx, eax
  00059	8b d0		 mov	 edx, eax
  0005b	75 35		 jne	 SHORT $L148195
  0005d	c1 e9 0a	 shr	 ecx, 10			; 0000000aH
  00060	80 e1 1f	 and	 cl, 31			; 0000001fH
  00063	c0 e1 03	 shl	 cl, 3
  00066	88 4c 24 12	 mov	 BYTE PTR _Dest$[esp+6], cl
  0006a	c1 ea 05	 shr	 edx, 5
  0006d	8a c8		 mov	 cl, al
  0006f	80 e2 1f	 and	 dl, 31			; 0000001fH
  00072	80 e1 1f	 and	 cl, 31			; 0000001fH
  00075	c0 e2 03	 shl	 dl, 3
  00078	c0 e1 03	 shl	 cl, 3
  0007b	24 80		 and	 al, 128			; 00000080H
  0007d	5b		 pop	 ebx
  0007e	88 4c 24 0c	 mov	 BYTE PTR _Dest$[esp], cl

; 434  : 			}
; 435  : 
; 436  :       SetRGBAPixel (&Dest, pCurEntry[2], pCurEntry[1],
; 437  :                     pCurEntry[0], pCurEntry[3]);

  00082	88 54 24 0d	 mov	 BYTE PTR _Dest$[esp+1], dl
  00086	88 44 24 0f	 mov	 BYTE PTR _Dest$[esp+3], al

; 438  :       break;
; 439  :   }
; 440  :   return Dest;

  0008a	8b 44 24 0c	 mov	 eax, DWORD PTR _Dest$[esp]
  0008e	5e		 pop	 esi

; 441  : }

  0008f	c2 0c 00	 ret	 12			; 0000000cH
$L148195:

; 409  :        else
; 410  :         SetRGBAPixel (&Dest,
; 411  :                       (UCHAR)(((Src >> 10) & 31)*8),
; 412  :                       (UCHAR)(((Src >> 5) & 31)*8),
; 413  :                       (UCHAR)((Src & 31)*8),
; 414  :                       0xFF);

  00092	c1 ea 0a	 shr	 edx, 10			; 0000000aH
  00095	c1 e9 05	 shr	 ecx, 5
  00098	80 e2 1f	 and	 dl, 31			; 0000001fH
  0009b	80 e1 1f	 and	 cl, 31			; 0000001fH
  0009e	24 1f		 and	 al, 31			; 0000001fH
  000a0	c0 e2 03	 shl	 dl, 3
  000a3	c0 e1 03	 shl	 cl, 3
  000a6	c0 e0 03	 shl	 al, 3
  000a9	5b		 pop	 ebx
  000aa	88 54 24 0e	 mov	 BYTE PTR _Dest$[esp+2], dl
  000ae	88 4c 24 0d	 mov	 BYTE PTR _Dest$[esp+1], cl
  000b2	88 44 24 0c	 mov	 BYTE PTR _Dest$[esp], al
  000b6	c6 44 24 0f ff	 mov	 BYTE PTR _Dest$[esp+3], 255 ; 000000ffH

; 438  :       break;
; 439  :   }
; 440  :   return Dest;

  000bb	8b 44 24 0c	 mov	 eax, DWORD PTR _Dest$[esp]
  000bf	5e		 pop	 esi

; 441  : }

  000c0	c2 0c 00	 ret	 12			; 0000000cH
$L148204:

; 415  :       break;
; 416  :     case 24:
; 417  : 			for( i=0;i<3;i++ )
; 418  : 			{
; 419  : 			  pCurEntry[i] = *(pDataSrc + m_nTgaDataIdx); m_nTgaDataIdx+=sizeof(char);

  000c3	8b 4c 24 10	 mov	 ecx, DWORD PTR _pDataSrc$[esp+4]
  000c7	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000ca	8a 14 08	 mov	 dl, BYTE PTR [eax+ecx]
  000cd	40		 inc	 eax
  000ce	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  000d1	8a 1c 08	 mov	 bl, BYTE PTR [eax+ecx]
  000d4	40		 inc	 eax
  000d5	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  000d8	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]
  000db	40		 inc	 eax

; 420  : 			}
; 421  :       SetRGBAPixel (&Dest, pCurEntry[2],
; 422  :                     pCurEntry[1], pCurEntry[0], 0xFF);

  000dc	88 5c 24 11	 mov	 BYTE PTR _Dest$[esp+5], bl
  000e0	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  000e3	5b		 pop	 ebx
  000e4	88 4c 24 0e	 mov	 BYTE PTR _Dest$[esp+2], cl
  000e8	88 54 24 0c	 mov	 BYTE PTR _Dest$[esp], dl
  000ec	c6 44 24 0f ff	 mov	 BYTE PTR _Dest$[esp+3], 255 ; 000000ffH

; 438  :       break;
; 439  :   }
; 440  :   return Dest;

  000f1	8b 44 24 0c	 mov	 eax, DWORD PTR _Dest$[esp]
  000f5	5e		 pop	 esi

; 441  : }

  000f6	c2 0c 00	 ret	 12			; 0000000cH
$L148209:

; 423  :       break;
; 424  :     case 32:
; 425  : 			for( i=0;i<4;i++ )
; 426  : 			{
; 427  : 			  pCurEntry[i] = *(pDataSrc + m_nTgaDataIdx); m_nTgaDataIdx+=sizeof(char);

  000f9	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  000fc	8b 44 24 10	 mov	 eax, DWORD PTR _pDataSrc$[esp+4]
  00100	8a 1c 01	 mov	 bl, BYTE PTR [ecx+eax]
  00103	41		 inc	 ecx
  00104	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx
  00107	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  0010a	41		 inc	 ecx
  0010b	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx
  0010e	41		 inc	 ecx
  0010f	88 54 24 0d	 mov	 BYTE PTR _pCurEntry$[esp+5], dl
  00113	8a 54 01 ff	 mov	 dl, BYTE PTR [ecx+eax-1]
  00117	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx
  0011a	8a 04 01	 mov	 al, BYTE PTR [ecx+eax]
  0011d	41		 inc	 ecx

; 428  : 			}
; 429  : 
; 430  : 		  if( pCurEntry[3]==1 ) // Alpha value is 1.

  0011e	3c 01		 cmp	 al, 1
  00120	88 54 24 0e	 mov	 BYTE PTR _pCurEntry$[esp+6], dl
  00124	88 44 24 0f	 mov	 BYTE PTR _pCurEntry$[esp+7], al
  00128	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx
  0012b	75 44		 jne	 SHORT $L148214

; 431  : 			{
; 432  : 				printf( "R: %d G: %d B: %d ALPHA : %d\n",pCurEntry[2], pCurEntry[1], pCurEntry[0], pCurEntry[3] );

  0012d	0f b6 44 24 0d	 movzx	 eax, BYTE PTR _pCurEntry$[esp+5]
  00132	6a 01		 push	 1
  00134	0f b6 cb	 movzx	 ecx, bl
  00137	51		 push	 ecx
  00138	0f b6 ca	 movzx	 ecx, dl
  0013b	50		 push	 eax
  0013c	51		 push	 ecx
  0013d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@FGOPIHLE@R?3?5?$CFd?5G?3?5?$CFd?5B?3?5?$CFd?5ALPHA?5?3?5?$CFd?6?$AA@
  00142	e8 00 00 00 00	 call	 _printf

; 433  : 				printf( "left : %d right : %d\n", m_nReadPixelCount%640, m_nReadPixelCount%480 );

  00147	8b 76 30	 mov	 esi, DWORD PTR [esi+48]
  0014a	8b c6		 mov	 eax, esi
  0014c	99		 cdq
  0014d	b9 e0 01 00 00	 mov	 ecx, 480		; 000001e0H
  00152	f7 f9		 idiv	 ecx
  00154	8b c6		 mov	 eax, esi
  00156	b9 80 02 00 00	 mov	 ecx, 640		; 00000280H
  0015b	52		 push	 edx
  0015c	99		 cdq
  0015d	f7 f9		 idiv	 ecx
  0015f	52		 push	 edx
  00160	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@GOLGOKGK@left?5?3?5?$CFd?5right?5?3?5?$CFd?6?$AA@
  00165	e8 00 00 00 00	 call	 _printf
  0016a	8a 54 24 2e	 mov	 dl, BYTE PTR _pCurEntry$[esp+38]
  0016e	83 c4 20	 add	 esp, 32			; 00000020H
$L148214:

; 434  : 			}
; 435  : 
; 436  :       SetRGBAPixel (&Dest, pCurEntry[2], pCurEntry[1],
; 437  :                     pCurEntry[0], pCurEntry[3]);

  00171	8a 44 24 0f	 mov	 al, BYTE PTR _pCurEntry$[esp+7]
  00175	88 54 24 12	 mov	 BYTE PTR _Dest$[esp+6], dl
  00179	8a 54 24 0d	 mov	 dl, BYTE PTR _pCurEntry$[esp+5]
  0017d	88 5c 24 10	 mov	 BYTE PTR _Dest$[esp+4], bl
  00181	88 54 24 11	 mov	 BYTE PTR _Dest$[esp+5], dl
  00185	88 44 24 13	 mov	 BYTE PTR _Dest$[esp+7], al
$L148340:
  00189	5b		 pop	 ebx
$L148339:

; 438  :       break;
; 439  :   }
; 440  :   return Dest;

  0018a	8b 44 24 0c	 mov	 eax, DWORD PTR _Dest$[esp]
  0018e	5e		 pop	 esi

; 441  : }

  0018f	c2 0c 00	 ret	 12			; 0000000cH
  00192	8b ff		 npad	 2
$L148342:
  00194	00 00 00 00	 DD	 $L148190
  00198	00 00 00 00	 DD	 $L148192
  0019c	00 00 00 00	 DD	 $L148204
  001a0	00 00 00 00	 DD	 $L148209
  001a4	00 00 00 00	 DD	 $L148340
$L148338:
  001a8	00		 DB	 0
  001a9	04		 DB	 4
  001aa	04		 DB	 4
  001ab	04		 DB	 4
  001ac	04		 DB	 4
  001ad	04		 DB	 4
  001ae	04		 DB	 4
  001af	01		 DB	 1
  001b0	01		 DB	 1
  001b1	04		 DB	 4
  001b2	04		 DB	 4
  001b3	04		 DB	 4
  001b4	04		 DB	 4
  001b5	04		 DB	 4
  001b6	04		 DB	 4
  001b7	04		 DB	 4
  001b8	02		 DB	 2
  001b9	04		 DB	 4
  001ba	04		 DB	 4
  001bb	04		 DB	 4
  001bc	04		 DB	 4
  001bd	04		 DB	 4
  001be	04		 DB	 4
  001bf	04		 DB	 4
  001c0	03		 DB	 3
?readPixel32@CTarga@@AAEKHPADPAK@Z ENDP			; CTarga::readPixel32
_TEXT	ENDS
PUBLIC	?readPixel8@CTarga@@AAEEHPAD@Z			; CTarga::readPixel8
PUBLIC	??_C@_0N@JEFBGOJP@8bit?5disable?$AA@		; `string'
;	COMDAT ??_C@_0N@JEFBGOJP@8bit?5disable?$AA@
CONST	SEGMENT
??_C@_0N@JEFBGOJP@8bit?5disable?$AA@ DB '8bit disable', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?readPixel8@CTarga@@AAEEHPAD@Z
_TEXT	SEGMENT
_bpp$ = 8						; size = 4
_pDataSrc$ = 12						; size = 4
?readPixel8@CTarga@@AAEEHPAD@Z PROC NEAR		; CTarga::readPixel8, COMDAT
; _this$ = ecx

; 445  :   UCHAR Dest;
; 446  : 
; 447  :   if(bpp != 8)

  00000	83 7c 24 04 08	 cmp	 DWORD PTR _bpp$[esp-4], 8
  00005	74 12		 je	 SHORT $L148223

; 448  : 	{
; 449  : 		printf( "8bit disable" );

  00007	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@JEFBGOJP@8bit?5disable?$AA@
  0000c	e8 00 00 00 00	 call	 _printf
  00011	83 c4 04	 add	 esp, 4

; 450  : 		return 0;

  00014	32 c0		 xor	 al, al

; 453  : 
; 454  :   return Dest;
; 455  : }

  00016	c2 08 00	 ret	 8
$L148223:

; 451  : 	}
; 452  :   Dest = *(pDataSrc + m_nTgaDataIdx); m_nTgaDataIdx+=sizeof(char);

  00019	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  0001c	8b 44 24 08	 mov	 eax, DWORD PTR _pDataSrc$[esp-4]
  00020	8a 04 02	 mov	 al, BYTE PTR [edx+eax]
  00023	42		 inc	 edx
  00024	89 51 2c	 mov	 DWORD PTR [ecx+44], edx

; 453  : 
; 454  :   return Dest;
; 455  : }

  00027	c2 08 00	 ret	 8
?readPixel8@CTarga@@AAEEHPAD@Z ENDP			; CTarga::readPixel8
_TEXT	ENDS
PUBLIC	??0CFileIO@@QAE@XZ				; CFileIO::CFileIO
PUBLIC	?Flush@CFileIO@@UAEHXZ				; CFileIO::Flush
PUBLIC	?GetC@CFileIO@@UAEDXZ				; CFileIO::GetC
PUBLIC	?GetW@CFileIO@@UAEGXZ				; CFileIO::GetW
PUBLIC	?GetDW@CFileIO@@UAEKXZ				; CFileIO::GetDW
PUBLIC	?Tell@CFileIO@@UAEJXZ				; CFileIO::Tell
PUBLIC	?Seek@CFileIO@@UAEHJH@Z				; CFileIO::Seek
PUBLIC	?GetLength@CFileIO@@UAEJXZ			; CFileIO::GetLength
PUBLIC	?Read@CFileIO@@UAEIPAXII@Z			; CFileIO::Read
PUBLIC	??_7CFileIO@@6B@				; CFileIO::`vftable'
PUBLIC	??_GCFileIO@@UAEPAXI@Z				; CFileIO::`scalar deleting destructor'
EXTRN	?Open@CFileIO@@UAEHPBDPAD@Z:NEAR		; CFileIO::Open
EXTRN	?Close@CFileIO@@UAEHXZ:NEAR			; CFileIO::Close
EXTRN	?Read@CFileIO@@UAEPAXXZ:NEAR			; CFileIO::Read
EXTRN	??_ECFileIO@@UAEPAXI@Z:NEAR			; CFileIO::`vector deleting destructor'
;	COMDAT ??_7CFileIO@@6B@
; File c:\offi src_real\offi src!\_common\file.h
CONST	SEGMENT
??_7CFileIO@@6B@ DD FLAT:??_ECFileIO@@UAEPAXI@Z		; CFileIO::`vftable'
	DD	FLAT:?Open@CFileIO@@UAEHPBDPAD@Z
	DD	FLAT:?Close@CFileIO@@UAEHXZ
	DD	FLAT:?Flush@CFileIO@@UAEHXZ
	DD	FLAT:?GetC@CFileIO@@UAEDXZ
	DD	FLAT:?GetW@CFileIO@@UAEGXZ
	DD	FLAT:?GetDW@CFileIO@@UAEKXZ
	DD	FLAT:?Tell@CFileIO@@UAEJXZ
	DD	FLAT:?Seek@CFileIO@@UAEHJH@Z
	DD	FLAT:?GetLength@CFileIO@@UAEJXZ
	DD	FLAT:?Read@CFileIO@@UAEPAXXZ
	DD	FLAT:?Read@CFileIO@@UAEIPAXII@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0CFileIO@@QAE@XZ
_TEXT	SEGMENT
??0CFileIO@@QAE@XZ PROC NEAR				; CFileIO::CFileIO, COMDAT
; _this$ = ecx

; 15   : 	CFileIO() { fp = NULL; } 

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CFileIO@@6B@
  00008	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0000f	c3		 ret	 0
??0CFileIO@@QAE@XZ ENDP					; CFileIO::CFileIO
_TEXT	ENDS
PUBLIC	??1CFileIO@@UAE@XZ				; CFileIO::~CFileIO
; Function compile flags: /Ogty
;	COMDAT ??1CFileIO@@UAE@XZ
_TEXT	SEGMENT
??1CFileIO@@UAE@XZ PROC NEAR				; CFileIO::~CFileIO, COMDAT
; _this$ = ecx

; 17   : 	virtual ~CFileIO() { Close(); }

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7CFileIO@@6B@
  00006	e9 00 00 00 00	 jmp	 ?Close@CFileIO@@UAEHXZ	; CFileIO::Close
??1CFileIO@@UAE@XZ ENDP					; CFileIO::~CFileIO
_TEXT	ENDS
EXTRN	_fflush:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Flush@CFileIO@@UAEHXZ
_TEXT	SEGMENT
?Flush@CFileIO@@UAEHXZ PROC NEAR			; CFileIO::Flush, COMDAT
; _this$ = ecx

; 20   : 	virtual int	 Flush()  { return fflush( fp ); }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 _fflush
  00009	83 c4 04	 add	 esp, 4
  0000c	c3		 ret	 0
?Flush@CFileIO@@UAEHXZ ENDP				; CFileIO::Flush
_TEXT	ENDS
EXTRN	_getc:NEAR
; Function compile flags: /Ogty
;	COMDAT ?GetC@CFileIO@@UAEDXZ
_TEXT	SEGMENT
?GetC@CFileIO@@UAEDXZ PROC NEAR				; CFileIO::GetC, COMDAT
; _this$ = ecx

; 21   : 	virtual char  GetC()  { return (char)getc( fp ); }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 _getc
  00009	83 c4 04	 add	 esp, 4
  0000c	c3		 ret	 0
?GetC@CFileIO@@UAEDXZ ENDP				; CFileIO::GetC
_TEXT	ENDS
EXTRN	_fgetwc:NEAR
; Function compile flags: /Ogty
;	COMDAT ?GetW@CFileIO@@UAEGXZ
_TEXT	SEGMENT
?GetW@CFileIO@@UAEGXZ PROC NEAR				; CFileIO::GetW, COMDAT
; _this$ = ecx

; 22   : 	virtual WORD  GetW()  { return getwc( fp ); } 

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 _fgetwc
  00009	83 c4 04	 add	 esp, 4
  0000c	c3		 ret	 0
?GetW@CFileIO@@UAEGXZ ENDP				; CFileIO::GetW
_TEXT	ENDS
EXTRN	_fread:NEAR
; Function compile flags: /Ogty
;	COMDAT ?GetDW@CFileIO@@UAEKXZ
_TEXT	SEGMENT
_dw$ = -4						; size = 4
?GetDW@CFileIO@@UAEKXZ PROC NEAR			; CFileIO::GetDW, COMDAT
; _this$ = ecx

; 23   : 	virtual DWORD GetDW() { DWORD dw; fread( &dw, sizeof( dw ), 1, fp ); return dw; }

  00000	51		 push	 ecx
  00001	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00004	50		 push	 eax
  00005	6a 01		 push	 1
  00007	8d 4c 24 08	 lea	 ecx, DWORD PTR _dw$[esp+12]
  0000b	6a 04		 push	 4
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 _fread
  00013	8b 44 24 10	 mov	 eax, DWORD PTR _dw$[esp+20]
  00017	83 c4 14	 add	 esp, 20			; 00000014H
  0001a	c3		 ret	 0
?GetDW@CFileIO@@UAEKXZ ENDP				; CFileIO::GetDW
_TEXT	ENDS
EXTRN	_ftell:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Tell@CFileIO@@UAEJXZ
_TEXT	SEGMENT
?Tell@CFileIO@@UAEJXZ PROC NEAR				; CFileIO::Tell, COMDAT
; _this$ = ecx

; 24   : 	virtual long Tell()   { return ftell(fp); }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 _ftell
  00009	83 c4 04	 add	 esp, 4
  0000c	c3		 ret	 0
?Tell@CFileIO@@UAEJXZ ENDP				; CFileIO::Tell
_TEXT	ENDS
EXTRN	_fseek:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Seek@CFileIO@@UAEHJH@Z
_TEXT	SEGMENT
_offset$ = 8						; size = 4
_whence$ = 12						; size = 4
?Seek@CFileIO@@UAEHJH@Z PROC NEAR			; CFileIO::Seek, COMDAT
; _this$ = ecx

; 25   : 	virtual int  Seek( long offset, int whence ) { return fseek( fp, offset, whence ); }

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _whence$[esp-4]
  00004	8b 54 24 04	 mov	 edx, DWORD PTR _offset$[esp-4]
  00008	50		 push	 eax
  00009	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0000c	52		 push	 edx
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 _fseek
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH
  00016	c2 08 00	 ret	 8
?Seek@CFileIO@@UAEHJH@Z ENDP				; CFileIO::Seek
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Read@CFileIO@@UAEIPAXII@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_size$ = 12						; size = 4
_n$ = 16						; size = 4
?Read@CFileIO@@UAEIPAXII@Z PROC NEAR			; CFileIO::Read, COMDAT
; _this$ = ecx

; 27   : 	virtual size_t Read( void *ptr, size_t size, size_t n = 1 )	{ return fread( ptr, size, n, fp ); }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	8b 4c 24 0c	 mov	 ecx, DWORD PTR _n$[esp-4]
  00007	8b 54 24 08	 mov	 edx, DWORD PTR _size$[esp-4]
  0000b	50		 push	 eax
  0000c	8b 44 24 08	 mov	 eax, DWORD PTR _ptr$[esp]
  00010	51		 push	 ecx
  00011	52		 push	 edx
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _fread
  00018	83 c4 10	 add	 esp, 16			; 00000010H
  0001b	c2 0c 00	 ret	 12			; 0000000cH
?Read@CFileIO@@UAEIPAXII@Z ENDP				; CFileIO::Read
_TEXT	ENDS
PUBLIC	?Handle@CFileIO@@QAEHXZ				; CFileIO::Handle
EXTRN	_fileno:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Handle@CFileIO@@QAEHXZ
_TEXT	SEGMENT
?Handle@CFileIO@@QAEHXZ PROC NEAR			; CFileIO::Handle, COMDAT
; _this$ = ecx

; 30   : 	int  Handle() { return fileno( fp ); }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 _fileno
  00009	83 c4 04	 add	 esp, 4
  0000c	c3		 ret	 0
?Handle@CFileIO@@QAEHXZ ENDP				; CFileIO::Handle
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_GCFileIO@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCFileIO@@UAEPAXI@Z PROC NEAR			; CFileIO::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CFileIO@@6B@
  00009	e8 00 00 00 00	 call	 ?Close@CFileIO@@UAEHXZ	; CFileIO::Close
  0000e	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  00013	74 09		 je	 SHORT $L148382
  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001b	83 c4 04	 add	 esp, 4
$L148382:
  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	c2 04 00	 ret	 4
??_GCFileIO@@UAEPAXI@Z ENDP				; CFileIO::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?readPalette@CTarga@@AAEXHHHPAPAKHPAD@Z		; CTarga::readPalette
PUBLIC	??_C@_0BL@DLNPHJME@Out?5of?5memory?5for?5palette?4?$AA@ ; `string'
;	COMDAT ??_C@_0BL@DLNPHJME@Out?5of?5memory?5for?5palette?4?$AA@
; File c:\offi src_real\offi src!\_common\targa.cpp
CONST	SEGMENT
??_C@_0BL@DLNPHJME@Out?5of?5memory?5for?5palette?4?$AA@ DB 'Out of memory'
	DB	' for palette.', 00H				; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?readPalette@CTarga@@AAEXHHHPAPAKHPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_StartIndex$ = 8					; size = 4
_Length$ = 12						; size = 4
_EntrySize$ = 16					; size = 4
_ppPal$ = 20						; size = 4
_DestBPP$ = 24						; size = 4
_pDataSrc$ = 28						; size = 4
?readPalette@CTarga@@AAEXHHHPAPAKHPAD@Z PROC NEAR	; CTarga::readPalette, COMDAT
; _this$ = ecx

; 216  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	56		 push	 esi
  00003	57		 push	 edi

; 217  :   int   i;
; 218  : 
; 219  :   *ppPal = new DWORD [256];

  00004	68 00 04 00 00	 push	 1024			; 00000400H
  00009	89 4c 24 10	 mov	 DWORD PTR _this$[esp+20], ecx
  0000d	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00012	8b 7c 24 24	 mov	 edi, DWORD PTR _ppPal$[esp+16]
  00016	83 c4 04	 add	 esp, 4

; 220  :   if (!(*ppPal)) printf("Out of memory for palette.");

  00019	85 c0		 test	 eax, eax
  0001b	89 07		 mov	 DWORD PTR [edi], eax
  0001d	75 0d		 jne	 SHORT $L148044
  0001f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BL@DLNPHJME@Out?5of?5memory?5for?5palette?4?$AA@
  00024	e8 00 00 00 00	 call	 _printf
  00029	83 c4 04	 add	 esp, 4
$L148044:

; 221  : 
; 222  :   for (i=StartIndex; i<StartIndex+Length; i++)

  0002c	8b 74 24 14	 mov	 esi, DWORD PTR _StartIndex$[esp+12]
  00030	8b 44 24 18	 mov	 eax, DWORD PTR _Length$[esp+12]
  00034	8d 1c 06	 lea	 ebx, DWORD PTR [esi+eax]
  00037	3b f3		 cmp	 esi, ebx
  00039	7d 22		 jge	 SHORT $L148048
  0003b	55		 push	 ebp
  0003c	8b 6c 24 2c	 mov	 ebp, DWORD PTR _pDataSrc$[esp+16]
$L148046:

; 223  :   {
; 224  :     (*ppPal)[i] = readPixel32 (EntrySize, pDataSrc, *ppPal);

  00040	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00042	8b 54 24 20	 mov	 edx, DWORD PTR _EntrySize$[esp+16]
  00046	51		 push	 ecx
  00047	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+24]
  0004b	55		 push	 ebp
  0004c	52		 push	 edx
  0004d	e8 00 00 00 00	 call	 ?readPixel32@CTarga@@AAEKHPADPAK@Z ; CTarga::readPixel32
  00052	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00054	89 04 b1	 mov	 DWORD PTR [ecx+esi*4], eax
  00057	46		 inc	 esi
  00058	3b f3		 cmp	 esi, ebx
  0005a	7c e4		 jl	 SHORT $L148046
  0005c	5d		 pop	 ebp
$L148048:
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx

; 225  :   }
; 226  : 
; 227  :   if (DestBPP == 8)
; 228  : 	{
; 229  : 	}
; 230  : }

  00060	59		 pop	 ecx
  00061	c2 18 00	 ret	 24			; 00000018H
?readPalette@CTarga@@AAEXHHHPAPAKHPAD@Z ENDP		; CTarga::readPalette
_TEXT	ENDS
PUBLIC	?expandUncompressedLine@CTarga@@AAEXPAEH_NHPADPAKH@Z ; CTarga::expandUncompressedLine
; Function compile flags: /Ogty
;	COMDAT ?expandUncompressedLine@CTarga@@AAEXPAEH_NHPADPAKH@Z
_TEXT	SEGMENT
_pDest$ = 8						; size = 4
tv90 = 12						; size = 4
_Width$ = 12						; size = 4
_bReversed$ = 16					; size = 1
_bpp$ = 20						; size = 4
_pDataSrc$ = 24						; size = 4
_pPal$ = 28						; size = 4
_DestBPP$ = 32						; size = 4
?expandUncompressedLine@CTarga@@AAEXPAEH_NHPADPAKH@Z PROC NEAR ; CTarga::expandUncompressedLine, COMDAT
; _this$ = ecx

; 323  :   int x;
; 324  : 
; 325  :   for (x=0; x<Width; x++)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _Width$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	7e 60		 jle	 SHORT $L148134
  0000b	53		 push	 ebx
  0000c	8b 5c 24 1c	 mov	 ebx, DWORD PTR _pDataSrc$[esp+4]
  00010	55		 push	 ebp
  00011	8b 6c 24 1c	 mov	 ebp, DWORD PTR _bpp$[esp+8]
  00015	57		 push	 edi
  00016	8b 7c 24 14	 mov	 edi, DWORD PTR _pDest$[esp+12]
  0001a	89 44 24 18	 mov	 DWORD PTR tv90[esp+12], eax
  0001e	8b ff		 npad	 2
$L148132:

; 326  :   {
; 327  :     if (DestBPP == 32)

  00020	83 7c 24 2c 20	 cmp	 DWORD PTR _DestBPP$[esp+12], 32 ; 00000020H
  00025	75 18		 jne	 SHORT $L148135

; 328  :     {
; 329  :       *((DWORD *)pDest) = readPixel32 (bpp, pDataSrc, pPal); m_nReadPixelCount++;

  00027	8b 44 24 28	 mov	 eax, DWORD PTR _pPal$[esp+12]
  0002b	50		 push	 eax
  0002c	53		 push	 ebx
  0002d	55		 push	 ebp
  0002e	8b ce		 mov	 ecx, esi
  00030	e8 00 00 00 00	 call	 ?readPixel32@CTarga@@AAEKHPADPAK@Z ; CTarga::readPixel32
  00035	89 07		 mov	 DWORD PTR [edi], eax
  00037	ff 46 30	 inc	 DWORD PTR [esi+48]

; 330  :       pDest += 4;

  0003a	83 c7 04	 add	 edi, 4

; 331  :     }
; 332  :     else

  0003d	eb 23		 jmp	 SHORT $L148133
$L148135:

; 333  :     {
; 334  :       *pDest = readPixel8 (bpp, pDataSrc);

  0003f	83 fd 08	 cmp	 ebp, 8
  00042	74 11		 je	 SHORT $L148396
  00044	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@JEFBGOJP@8bit?5disable?$AA@
  00049	e8 00 00 00 00	 call	 _printf
  0004e	83 c4 04	 add	 esp, 4
  00051	32 c9		 xor	 cl, cl
  00053	eb 0a		 jmp	 SHORT $L148394
$L148396:
  00055	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00058	8a 0c 18	 mov	 cl, BYTE PTR [eax+ebx]
  0005b	40		 inc	 eax
  0005c	89 46 2c	 mov	 DWORD PTR [esi+44], eax
$L148394:
  0005f	88 0f		 mov	 BYTE PTR [edi], cl

; 335  :       pDest ++;

  00061	47		 inc	 edi
$L148133:
  00062	ff 4c 24 18	 dec	 DWORD PTR tv90[esp+12]
  00066	75 b8		 jne	 SHORT $L148132
  00068	5f		 pop	 edi
  00069	5d		 pop	 ebp
  0006a	5b		 pop	 ebx
$L148134:
  0006b	5e		 pop	 esi

; 336  :     }
; 337  :   }
; 338  : }

  0006c	c2 1c 00	 ret	 28			; 0000001cH
?expandUncompressedLine@CTarga@@AAEXPAEH_NHPADPAKH@Z ENDP ; CTarga::expandUncompressedLine
_TEXT	ENDS
PUBLIC	?expandCompressedLine@CTarga@@AAEXPAEH_NHPADPAKH@Z ; CTarga::expandCompressedLine
; Function compile flags: /Ogty
;	COMDAT ?expandCompressedLine@CTarga@@AAEXPAEH_NHPADPAKH@Z
_TEXT	SEGMENT
_x$ = -4						; size = 4
_i$ = 8							; size = 4
_pDest$ = 8						; size = 4
_Width$ = 12						; size = 4
_bReversed$ = 16					; size = 1
_bpp$ = 20						; size = 4
_pDataSrc$ = 24						; size = 4
_pPal$ = 28						; size = 4
_DestBPP$ = 32						; size = 4
?expandCompressedLine@CTarga@@AAEXPAEH_NHPADPAKH@Z PROC NEAR ; CTarga::expandCompressedLine, COMDAT
; _this$ = ecx

; 340  : {

  00000	51		 push	 ecx

; 341  :   int  x;
; 342  :   int  i;
; 343  :   UCHAR Count;
; 344  : 
; 345  :   for (x=0; x<Width; )

  00001	8b 44 24 0c	 mov	 eax, DWORD PTR _Width$[esp]
  00005	85 c0		 test	 eax, eax
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR _x$[esp+8], 0
  00012	0f 8e 4b 01 00
	00		 jle	 $L148153
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	8b 6c 24 14	 mov	 ebp, DWORD PTR _pDest$[esp+12]
  0001e	57		 push	 edi
  0001f	90		 npad	 1
$L148152:

; 346  :   {
; 347  :     Count = *(pDataSrc + m_nTgaDataIdx); m_nTgaDataIdx+=sizeof(char);

  00020	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  00023	8b 44 24 28	 mov	 eax, DWORD PTR _pDataSrc$[esp+16]
  00027	8a 1c 01	 mov	 bl, BYTE PTR [ecx+eax]
  0002a	41		 inc	 ecx

; 348  :     if (Count & 128)

  0002b	84 db		 test	 bl, bl
  0002d	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx
  00030	0f 89 8e 00 00
	00		 jns	 $L148155

; 349  :     { // RLE-Encoded packet
; 350  :       Count -= 127; // Calculate real repeat count.
; 351  :       if (DestBPP == 32)

  00036	8b 54 24 30	 mov	 edx, DWORD PTR _DestBPP$[esp+16]
  0003a	80 c3 81	 add	 bl, 129			; 00000081H
  0003d	83 fa 20	 cmp	 edx, 32			; 00000020H
  00040	75 43		 jne	 SHORT $L148156

; 352  :       {
; 353  :         *((DWORD *)pDest) = readPixel32 (bpp, pDataSrc, pPal); 

  00042	8b 4c 24 2c	 mov	 ecx, DWORD PTR _pPal$[esp+16]
  00046	8b 54 24 24	 mov	 edx, DWORD PTR _bpp$[esp+16]
  0004a	51		 push	 ecx
  0004b	50		 push	 eax
  0004c	52		 push	 edx
  0004d	8b ce		 mov	 ecx, esi
  0004f	e8 00 00 00 00	 call	 ?readPixel32@CTarga@@AAEKHPADPAK@Z ; CTarga::readPixel32
  00054	89 45 00	 mov	 DWORD PTR [ebp], eax

; 354  : 				m_nReadPixelCount++;

  00057	8b 56 30	 mov	 edx, DWORD PTR [esi+48]

; 355  : 
; 356  :         for (i=1; i<Count; i++) *((DWORD *)(pDest+i*4)) = *(DWORD *)pDest;

  0005a	0f b6 fb	 movzx	 edi, bl
  0005d	42		 inc	 edx
  0005e	b8 01 00 00 00	 mov	 eax, 1
  00063	3b f8		 cmp	 edi, eax
  00065	89 56 30	 mov	 DWORD PTR [esi+48], edx
  00068	0f 8e d4 00 00
	00		 jle	 $L148429
  0006e	8b ff		 npad	 2
$L148158:
  00070	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  00073	89 4c 85 00	 mov	 DWORD PTR [ebp+eax*4], ecx
  00077	40		 inc	 eax
  00078	3b c7		 cmp	 eax, edi
  0007a	7c f4		 jl	 SHORT $L148158

; 378  : 				}
; 379  :       }
; 380  :     }
; 381  :     if (DestBPP == 32) pDest += Count*4; else pDest += Count;

  0007c	8d 6c bd 00	 lea	 ebp, DWORD PTR [ebp+edi*4]
  00080	e9 c5 00 00 00	 jmp	 $L148175
$L148156:

; 357  :       }
; 358  :       else
; 359  :       {
; 360  :         *pDest = readPixel8 (bpp, pDataSrc);

  00085	83 7c 24 24 08	 cmp	 DWORD PTR _bpp$[esp+16], 8
  0008a	74 11		 je	 SHORT $L148407
  0008c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@JEFBGOJP@8bit?5disable?$AA@
  00091	e8 00 00 00 00	 call	 _printf
  00096	83 c4 04	 add	 esp, 4
  00099	32 c0		 xor	 al, al
  0009b	eb 07		 jmp	 SHORT $L148405
$L148407:
  0009d	8a 04 01	 mov	 al, BYTE PTR [ecx+eax]
  000a0	41		 inc	 ecx
  000a1	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx
$L148405:

; 361  :         for (i=1; i<Count; i++)

  000a4	0f b6 fb	 movzx	 edi, bl
  000a7	88 45 00	 mov	 BYTE PTR [ebp], al
  000aa	b8 01 00 00 00	 mov	 eax, 1
  000af	3b f8		 cmp	 edi, eax
  000b1	0f 8e 84 00 00
	00		 jle	 $L148428
$L148164:

; 362  :           *(pDest+i) = *pDest;

  000b7	8a 55 00	 mov	 dl, BYTE PTR [ebp]
  000ba	88 14 28	 mov	 BYTE PTR [eax+ebp], dl
  000bd	40		 inc	 eax
  000be	3b c7		 cmp	 eax, edi
  000c0	7c f5		 jl	 SHORT $L148164

; 363  :       }
; 364  :     }
; 365  :     else

  000c2	eb 77		 jmp	 SHORT $L148428
$L148155:

; 366  :     { // Raw packet
; 367  :       Count += 1; // Calculate real repeat count.

  000c4	fe c3		 inc	 bl

; 368  :       for (i=0; i<Count; i++)

  000c6	0f b6 fb	 movzx	 edi, bl
  000c9	85 ff		 test	 edi, edi
  000cb	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _i$[esp+16], 0
  000d3	7e 66		 jle	 SHORT $L148428
$L148168:

; 369  :       {
; 370  :         if (DestBPP == 32)

  000d5	83 7c 24 30 20	 cmp	 DWORD PTR _DestBPP$[esp+16], 32 ; 00000020H
  000da	75 23		 jne	 SHORT $L148171

; 371  : 				{
; 372  :           *((DWORD *)(pDest+i*4)) = readPixel32 (bpp, pDataSrc, pPal); 

  000dc	8b 4c 24 2c	 mov	 ecx, DWORD PTR _pPal$[esp+16]
  000e0	8b 54 24 24	 mov	 edx, DWORD PTR _bpp$[esp+16]
  000e4	51		 push	 ecx
  000e5	50		 push	 eax
  000e6	52		 push	 edx
  000e7	8b ce		 mov	 ecx, esi
  000e9	e8 00 00 00 00	 call	 ?readPixel32@CTarga@@AAEKHPADPAK@Z ; CTarga::readPixel32
  000ee	8b 4c 24 18	 mov	 ecx, DWORD PTR _i$[esp+16]
  000f2	89 44 8d 00	 mov	 DWORD PTR [ebp+ecx*4], eax

; 373  : 					m_nReadPixelCount++;

  000f6	ff 46 30	 inc	 DWORD PTR [esi+48]

; 374  : 				}
; 375  :         else

  000f9	8b 44 24 28	 mov	 eax, DWORD PTR _pDataSrc$[esp+16]
  000fd	eb 2f		 jmp	 SHORT $L148169
$L148171:

; 376  : 				{
; 377  :           *(pDest+i) = readPixel8 (bpp, pDataSrc);

  000ff	83 7c 24 24 08	 cmp	 DWORD PTR _bpp$[esp+16], 8
  00104	74 15		 je	 SHORT $L148413
  00106	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@JEFBGOJP@8bit?5disable?$AA@
  0010b	e8 00 00 00 00	 call	 _printf
  00110	8b 44 24 2c	 mov	 eax, DWORD PTR _pDataSrc$[esp+20]
  00114	83 c4 04	 add	 esp, 4
  00117	32 c9		 xor	 cl, cl
  00119	eb 0c		 jmp	 SHORT $L148411
$L148413:
  0011b	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  0011e	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  00121	41		 inc	 ecx
  00122	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx
  00125	8a ca		 mov	 cl, dl
$L148411:
  00127	8b 54 24 18	 mov	 edx, DWORD PTR _i$[esp+16]
  0012b	88 0c 2a	 mov	 BYTE PTR [edx+ebp], cl
$L148169:
  0012e	8b 4c 24 18	 mov	 ecx, DWORD PTR _i$[esp+16]
  00132	41		 inc	 ecx
  00133	3b cf		 cmp	 ecx, edi
  00135	89 4c 24 18	 mov	 DWORD PTR _i$[esp+16], ecx
  00139	7c 9a		 jl	 SHORT $L148168
$L148428:

; 378  : 				}
; 379  :       }
; 380  :     }
; 381  :     if (DestBPP == 32) pDest += Count*4; else pDest += Count;

  0013b	83 7c 24 30 20	 cmp	 DWORD PTR _DestBPP$[esp+16], 32 ; 00000020H
  00140	75 06		 jne	 SHORT $L148174
$L148429:
  00142	8d 6c bd 00	 lea	 ebp, DWORD PTR [ebp+edi*4]
  00146	eb 02		 jmp	 SHORT $L148175
$L148174:
  00148	03 ef		 add	 ebp, edi
$L148175:

; 382  : 		x += Count;

  0014a	8b 44 24 10	 mov	 eax, DWORD PTR _x$[esp+20]
  0014e	8b 4c 24 1c	 mov	 ecx, DWORD PTR _Width$[esp+16]
  00152	03 c7		 add	 eax, edi
  00154	3b c1		 cmp	 eax, ecx
  00156	89 44 24 10	 mov	 DWORD PTR _x$[esp+20], eax
  0015a	0f 8c c0 fe ff
	ff		 jl	 $L148152
  00160	5f		 pop	 edi
  00161	5d		 pop	 ebp
  00162	5b		 pop	 ebx
$L148153:
  00163	5e		 pop	 esi

; 383  :   }
; 384  : }

  00164	59		 pop	 ecx
  00165	c2 1c 00	 ret	 28			; 0000001cH
?expandCompressedLine@CTarga@@AAEXPAEH_NHPADPAKH@Z ENDP	; CTarga::expandCompressedLine
_TEXT	ENDS
EXTRN	__filelength:NEAR
; Function compile flags: /Ogty
; File c:\offi src_real\offi src!\_common\file.h
;	COMDAT ?GetLength@CFileIO@@UAEJXZ
_TEXT	SEGMENT
?GetLength@CFileIO@@UAEJXZ PROC NEAR			; CFileIO::GetLength, COMDAT
; _this$ = ecx

; 26   : 	virtual long GetLength() { return _filelength( Handle() ); }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 _fileno
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 __filelength
  0000f	83 c4 08	 add	 esp, 8
  00012	c3		 ret	 0
?GetLength@CFileIO@@UAEJXZ ENDP				; CFileIO::GetLength
_TEXT	ENDS
PUBLIC	?DoDecode@CTarga@@AAEXPAPAKPAHPAD@Z		; CTarga::DoDecode
; Function compile flags: /Ogty
; File c:\offi src_real\offi src!\_common\targa.cpp
;	COMDAT ?DoDecode@CTarga@@AAEXPAPAKPAHPAD@Z
_TEXT	SEGMENT
_ppPal$ = 8						; size = 4
_pDestBPP$ = 12						; size = 4
_pDataSrc$ = 16						; size = 4
?DoDecode@CTarga@@AAEXPAPAKPAHPAD@Z PROC NEAR		; CTarga::DoDecode, COMDAT
; _this$ = ecx

; 164  : {

  00000	56		 push	 esi

; 165  : //  TGAHEADER m_header;
; 166  : 
; 167  :   readTgaHeader (&m_header, pDataSrc);

  00001	8b 74 24 10	 mov	 esi, DWORD PTR _pDataSrc$[esp]
  00005	56		 push	 esi
  00006	51		 push	 ecx
  00007	e8 00 00 00 00	 call	 ?readTgaHeader@CTarga@@AAEXPAU_TgaHeader@@PAD@Z ; CTarga::readTgaHeader

; 168  : 
; 169  :   if (*pDestBPP == 0)

  0000c	8b 44 24 0c	 mov	 eax, DWORD PTR _pDestBPP$[esp]
  00010	83 38 00	 cmp	 DWORD PTR [eax], 0
  00013	75 11		 jne	 SHORT $L148002

; 170  :   {
; 171  :     if (m_header.PixelDepth <= 8)

  00015	33 d2		 xor	 edx, edx
  00017	b2 08		 mov	 dl, 8
  00019	3a 51 1c	 cmp	 dl, BYTE PTR [ecx+28]
  0001c	1b d2		 sbb	 edx, edx
  0001e	83 e2 18	 and	 edx, 24			; 00000018H
  00021	83 c2 08	 add	 edx, 8
  00024	89 10		 mov	 DWORD PTR [eax], edx
$L148002:

; 172  :       *pDestBPP = 8;
; 173  :     else
; 174  :       *pDestBPP = 32;
; 175  :   }
; 176  : 
; 177  :   if (m_header.PixelDepth == 16 || m_header.PixelDepth == 32)
; 178  :     // Image has alpha channel
; 179  : 	{
; 180  : 	}
; 181  :   else
; 182  :     // Image doesn't have alpha channel
; 183  : 	{
; 184  : 	}
; 185  : 
; 186  :   // Read the color map data (Version 1.0 and 2.0).
; 187  :   if (m_header.CmapType != 0)

  00026	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  00029	84 d2		 test	 dl, dl
  0002b	74 1b		 je	 SHORT $L148007

; 188  :     readPalette (m_header.CmapIndex,m_header.CmapLength,m_header.CmapEntrySize,ppPal,*pDestBPP,pDataSrc);

  0002d	8b 00		 mov	 eax, DWORD PTR [eax]
  0002f	8b 54 24 08	 mov	 edx, DWORD PTR _ppPal$[esp]
  00033	56		 push	 esi
  00034	50		 push	 eax
  00035	0f b6 41 0b	 movzx	 eax, BYTE PTR [ecx+11]
  00039	52		 push	 edx
  0003a	8b 51 07	 mov	 edx, DWORD PTR [ecx+7]
  0003d	50		 push	 eax
  0003e	8b 41 03	 mov	 eax, DWORD PTR [ecx+3]
  00041	52		 push	 edx
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?readPalette@CTarga@@AAEXHHHPAPAKHPAD@Z ; CTarga::readPalette
$L148007:
  00048	5e		 pop	 esi

; 189  : 
; 190  : }

  00049	c2 0c 00	 ret	 12			; 0000000cH
?DoDecode@CTarga@@AAEXPAPAKPAHPAD@Z ENDP		; CTarga::DoDecode
_TEXT	ENDS
PUBLIC	?readData@CTarga@@AAEXPAU_TgaHeader@@_NPAKHPAD@Z ; CTarga::readData
; Function compile flags: /Ogty
;	COMDAT ?readData@CTarga@@AAEXPAU_TgaHeader@@_NPAKHPAD@Z
_TEXT	SEGMENT
_bYReversed$ = -9					; size = 1
_bpp$ = -8						; size = 4
_bXReversed$ = -4					; size = 1
_header$ = 8						; size = 4
_bCompressed$ = 12					; size = 1
_pPal$ = 16						; size = 4
tv162 = 20						; size = 4
_DestBPP$ = 20						; size = 4
_pDataSrc$ = 24						; size = 4
?readData@CTarga@@AAEXPAU_TgaHeader@@_NPAKHPAD@Z PROC NEAR ; CTarga::readData, COMDAT
; _this$ = ecx

; 266  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp

; 267  : 	int Width = m_header.ImageWidth;
; 268  : 	int Height = m_header.ImageHeight;
; 269  : 	int bpp = m_header.PixelDepth;
; 270  : 	int nAlign = 0;//GetWidth() - GetPgWidth();
; 271  : 
; 272  :   // Bits 4 & 5 of the Image Descriptor byte control the ordering of
; 273  :   // the pixels.
; 274  :   bool bXReversed = ((m_header.ImagDesc & 16) == 16);
; 275  :   bool bYReversed = ((m_header.ImagDesc & 32) == 32);
; 276  : 
; 277  :   UCHAR * pDest = (UCHAR*) m_pData;
; 278  : //  UCHAR ** pLineArray = pBmp->GetLineArray();
; 279  : 
; 280  : 	if(bYReversed == FALSE)

  00005	8b 6c 24 24	 mov	 ebp, DWORD PTR _DestBPP$[esp+16]
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	0f b6 46 1c	 movzx	 eax, BYTE PTR [esi+28]
  00010	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00013	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00016	89 44 24 10	 mov	 DWORD PTR _bpp$[esp+24], eax
  0001a	8a 46 1d	 mov	 al, BYTE PTR [esi+29]
  0001d	8a d0		 mov	 dl, al
  0001f	80 e2 10	 and	 dl, 16			; 00000010H
  00022	80 fa 10	 cmp	 dl, 16			; 00000010H
  00025	0f 94 c2	 sete	 dl
  00028	24 20		 and	 al, 32			; 00000020H
  0002a	3c 20		 cmp	 al, 32			; 00000020H
  0002c	0f 94 c0	 sete	 al
  0002f	84 c0		 test	 al, al
  00031	57		 push	 edi
  00032	8b 7e 20	 mov	 edi, DWORD PTR [esi+32]
  00035	88 54 24 18	 mov	 BYTE PTR _bXReversed$[esp+28], dl
  00039	88 44 24 13	 mov	 BYTE PTR _bYReversed$[esp+28], al
  0003d	75 1e		 jne	 SHORT $L148096

; 281  : 	{
; 282  : 		switch(DestBPP)

  0003f	83 fd 08	 cmp	 ebp, 8
  00042	74 0e		 je	 SHORT $L148099
  00044	83 fd 20	 cmp	 ebp, 32			; 00000020H
  00047	75 14		 jne	 SHORT $L148096

; 285  : 			case 32: pDest += ((m_header.ImageWidth+nAlign) * m_header.ImageHeight * 4) - ((m_header.ImageWidth+nAlign) * 4); break;

  00049	8d 14 8d fc ff
	ff ff		 lea	 edx, DWORD PTR [ecx*4-4]
  00050	eb 03		 jmp	 SHORT $L148445
$L148099:

; 283  : 		{
; 284  : 			case  8: pDest += ((m_header.ImageWidth+nAlign) * m_header.ImageHeight    ) - ( m_header.ImageWidth+nAlign     ); break;

  00052	8d 51 ff	 lea	 edx, DWORD PTR [ecx-1]
$L148445:
  00055	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00058	0f af d0	 imul	 edx, eax
  0005b	03 fa		 add	 edi, edx
$L148096:

; 286  : 		}
; 287  : 	}
; 288  :   for(int y = 0; y < Height; y++)

  0005d	85 c9		 test	 ecx, ecx
  0005f	0f 8e 9b 00 00
	00		 jle	 $L148104
  00065	89 4c 24 2c	 mov	 DWORD PTR tv162[esp+24], ecx
  00069	8d a4 24 00 00
	00 00		 npad	 7
$L148102:

; 289  :   {
; 290  : 		/*
; 291  : 	   if (bYReversed)
; 292  :       pDest = pLineArray[y];
; 293  :      else
; 294  :       pDest = pLineArray[Height-y-1];
; 295  : 			*/
; 296  :     if (!bCompressed)

  00070	8a 44 24 24	 mov	 al, BYTE PTR _bCompressed$[esp+24]
  00074	84 c0		 test	 al, al

; 297  :       expandUncompressedLine (pDest, Width, bXReversed, bpp, pDataSrc, pPal, DestBPP);

  00076	55		 push	 ebp
  00077	75 1f		 jne	 SHORT $L148105
  00079	8b 44 24 2c	 mov	 eax, DWORD PTR _pPal$[esp+28]
  0007d	8b 4c 24 34	 mov	 ecx, DWORD PTR _pDataSrc$[esp+28]
  00081	8b 54 24 18	 mov	 edx, DWORD PTR _bpp$[esp+32]
  00085	50		 push	 eax
  00086	8b 44 24 20	 mov	 eax, DWORD PTR _bXReversed$[esp+36]
  0008a	51		 push	 ecx
  0008b	52		 push	 edx
  0008c	50		 push	 eax
  0008d	53		 push	 ebx
  0008e	57		 push	 edi
  0008f	8b ce		 mov	 ecx, esi
  00091	e8 00 00 00 00	 call	 ?expandUncompressedLine@CTarga@@AAEXPAEH_NHPADPAKH@Z ; CTarga::expandUncompressedLine

; 298  :      else

  00096	eb 1d		 jmp	 SHORT $L148106
$L148105:

; 299  :       expandCompressedLine (pDest, Width, bXReversed, bpp, pDataSrc, pPal, DestBPP);

  00098	8b 4c 24 2c	 mov	 ecx, DWORD PTR _pPal$[esp+28]
  0009c	8b 54 24 34	 mov	 edx, DWORD PTR _pDataSrc$[esp+28]
  000a0	8b 44 24 18	 mov	 eax, DWORD PTR _bpp$[esp+32]
  000a4	51		 push	 ecx
  000a5	8b 4c 24 20	 mov	 ecx, DWORD PTR _bXReversed$[esp+36]
  000a9	52		 push	 edx
  000aa	50		 push	 eax
  000ab	51		 push	 ecx
  000ac	53		 push	 ebx
  000ad	57		 push	 edi
  000ae	8b ce		 mov	 ecx, esi
  000b0	e8 00 00 00 00	 call	 ?expandCompressedLine@CTarga@@AAEXPAEH_NHPADPAKH@Z ; CTarga::expandCompressedLine
$L148106:

; 300  : 		if(bYReversed == TRUE)

  000b5	80 7c 24 13 01	 cmp	 BYTE PTR _bYReversed$[esp+28], 1
  000ba	75 1f		 jne	 SHORT $L148107

; 301  : 		{
; 302  : 			switch(DestBPP)

  000bc	83 fd 08	 cmp	 ebp, 8
  000bf	74 11		 je	 SHORT $L148112
  000c1	83 fd 20	 cmp	 ebp, 32			; 00000020H
  000c4	75 0f		 jne	 SHORT $L148109

; 305  : 				case 32: pDest += (m_header.ImageWidth+nAlign)*4; break;

  000c6	8b 56 14	 mov	 edx, DWORD PTR [esi+20]

; 306  : 			}
; 307  : 			memset(pDest,0,nAlign);

  000c9	33 c9		 xor	 ecx, ecx
  000cb	8d 3c 97	 lea	 edi, DWORD PTR [edi+edx*4]
  000ce	33 c0		 xor	 eax, eax

; 308  : 			pDest += nAlign;
; 309  : 		}
; 310  : 		else

  000d0	eb 24		 jmp	 SHORT $L148103
$L148112:

; 303  : 			{
; 304  : 				case  8: pDest += (m_header.ImageWidth+nAlign)  ; break;

  000d2	03 7e 14	 add	 edi, DWORD PTR [esi+20]
$L148109:

; 306  : 			}
; 307  : 			memset(pDest,0,nAlign);

  000d5	33 c9		 xor	 ecx, ecx
  000d7	33 c0		 xor	 eax, eax

; 308  : 			pDest += nAlign;
; 309  : 		}
; 310  : 		else

  000d9	eb 1b		 jmp	 SHORT $L148103
$L148107:

; 311  : 		{
; 312  : 			memset(pDest,0,nAlign);

  000db	33 c9		 xor	 ecx, ecx
  000dd	33 c0		 xor	 eax, eax

; 313  : 			switch(DestBPP)

  000df	83 fd 08	 cmp	 ebp, 8
  000e2	74 0f		 je	 SHORT $L148119
  000e4	83 fd 20	 cmp	 ebp, 32			; 00000020H
  000e7	75 0d		 jne	 SHORT $L148103

; 316  : 				case 32: pDest -= (m_header.ImageWidth+nAlign)*4; break;

  000e9	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000ec	f7 d8		 neg	 eax
  000ee	8d 3c 87	 lea	 edi, DWORD PTR [edi+eax*4]
  000f1	eb 03		 jmp	 SHORT $L148103
$L148119:

; 314  : 			{
; 315  : 				case  8: pDest -= (m_header.ImageWidth+nAlign)  ; break;

  000f3	2b 7e 14	 sub	 edi, DWORD PTR [esi+20]
$L148103:
  000f6	ff 4c 24 2c	 dec	 DWORD PTR tv162[esp+24]
  000fa	0f 85 70 ff ff
	ff		 jne	 $L148102
$L148104:
  00100	5f		 pop	 edi
  00101	5e		 pop	 esi
  00102	5d		 pop	 ebp
  00103	5b		 pop	 ebx

; 317  : 			}
; 318  : 		}
; 319  :   }
; 320  : }

  00104	83 c4 0c	 add	 esp, 12			; 0000000cH
  00107	c2 14 00	 ret	 20			; 00000014H
?readData@CTarga@@AAEXPAU_TgaHeader@@_NPAKHPAD@Z ENDP	; CTarga::readData
_TEXT	ENDS
PUBLIC	?readImage@CTarga@@AAEXPAU_TgaHeader@@PAPAKHPAD@Z ; CTarga::readImage
PUBLIC	??_C@_0BI@NDPBCKEG@Unknown?5TGA?5image?5type?4?$AA@ ; `string'
;	COMDAT ??_C@_0BI@NDPBCKEG@Unknown?5TGA?5image?5type?4?$AA@
CONST	SEGMENT
??_C@_0BI@NDPBCKEG@Unknown?5TGA?5image?5type?4?$AA@ DB 'Unknown TGA image'
	DB	' type.', 00H				; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?readImage@CTarga@@AAEXPAU_TgaHeader@@PAPAKHPAD@Z
_TEXT	SEGMENT
_header$ = 8						; size = 4
_bCompressed$ = 12					; size = 1
_ppPal$ = 12						; size = 4
_DestBPP$ = 16						; size = 4
_pDataSrc$ = 20						; size = 4
?readImage@CTarga@@AAEXPAU_TgaHeader@@PAPAKHPAD@Z PROC NEAR ; CTarga::readImage, COMDAT
; _this$ = ecx

; 241  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 242  :   bool bCompressed;
; 243  : 
; 244  :   if (m_header.ImageType == TGA_Mono ||
; 245  :       m_header.ImageType == TGA_RLEMono)

  00003	8a 46 02	 mov	 al, BYTE PTR [esi+2]
  00006	3c 03		 cmp	 al, 3
  00008	57		 push	 edi
  00009	8b 7c 24 10	 mov	 edi, DWORD PTR _ppPal$[esp+4]
  0000d	74 04		 je	 SHORT $L148069
  0000f	3c 0b		 cmp	 al, 11			; 0000000bH
  00011	75 08		 jne	 SHORT $L148068
$L148069:

; 246  :     setGrayPalette (ppPal);

  00013	57		 push	 edi
  00014	8b ce		 mov	 ecx, esi
  00016	e8 00 00 00 00	 call	 ?setGrayPalette@CTarga@@AAEXPAPAK@Z ; CTarga::setGrayPalette
$L148068:

; 247  : 
; 248  :   switch (m_header.ImageType)

  0001b	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  0001f	48		 dec	 eax
  00020	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00023	77 1c		 ja	 SHORT $L148076
  00025	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $L148449[eax]
  0002c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L148450[eax*4]
$L148074:

; 249  :   {
; 250  :     case TGA_Map:
; 251  :     case TGA_RGB:
; 252  :     case TGA_Mono:
; 253  :       bCompressed = FALSE;

  00033	c6 44 24 10 00	 mov	 BYTE PTR _bCompressed$[esp+4], 0

; 254  :       break;

  00038	eb 14		 jmp	 SHORT $L148071
$L148075:

; 255  :     case TGA_RLEMap:
; 256  :     case TGA_RLERGB:
; 257  :     case TGA_RLEMono:
; 258  :       bCompressed = TRUE;

  0003a	c6 44 24 10 01	 mov	 BYTE PTR _bCompressed$[esp+4], 1

; 259  :       break;

  0003f	eb 0d		 jmp	 SHORT $L148071
$L148076:

; 260  :     default:
; 261  :       printf( "Unknown TGA image type." );

  00041	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BI@NDPBCKEG@Unknown?5TGA?5image?5type?4?$AA@
  00046	e8 00 00 00 00	 call	 _printf
  0004b	83 c4 04	 add	 esp, 4
$L148071:

; 262  :   }
; 263  :   readData (header, bCompressed, *ppPal, DestBPP, pDataSrc);

  0004e	8b 4c 24 18	 mov	 ecx, DWORD PTR _pDataSrc$[esp+4]
  00052	8b 54 24 14	 mov	 edx, DWORD PTR _DestBPP$[esp+4]
  00056	8b 07		 mov	 eax, DWORD PTR [edi]
  00058	51		 push	 ecx
  00059	8b 4c 24 14	 mov	 ecx, DWORD PTR _bCompressed$[esp+8]
  0005d	52		 push	 edx
  0005e	8b 54 24 14	 mov	 edx, DWORD PTR _header$[esp+12]
  00062	50		 push	 eax
  00063	51		 push	 ecx
  00064	52		 push	 edx
  00065	8b ce		 mov	 ecx, esi
  00067	e8 00 00 00 00	 call	 ?readData@CTarga@@AAEXPAU_TgaHeader@@_NPAKHPAD@Z ; CTarga::readData
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi

; 264  : }

  0006e	c2 10 00	 ret	 16			; 00000010H
  00071	8d 49 00	 npad	 3
$L148450:
  00074	00 00 00 00	 DD	 $L148074
  00078	00 00 00 00	 DD	 $L148075
  0007c	00 00 00 00	 DD	 $L148076
$L148449:
  00080	00		 DB	 0
  00081	00		 DB	 0
  00082	00		 DB	 0
  00083	02		 DB	 2
  00084	02		 DB	 2
  00085	02		 DB	 2
  00086	02		 DB	 2
  00087	02		 DB	 2
  00088	01		 DB	 1
  00089	01		 DB	 1
  0008a	01		 DB	 1
?readImage@CTarga@@AAEXPAU_TgaHeader@@PAPAKHPAD@Z ENDP	; CTarga::readImage
_TEXT	ENDS
PUBLIC	?Load@CTarga@@QAEHPBDPAPAEPAUtagSIZE@@@Z	; CTarga::Load
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_0BJ@MAKCNCEN@CTarga?3?3Load?5Failed?5?$DN?5?$CFs?$AA@ ; `string'
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	?Error@@YAPBDPBDZZ:NEAR				; Error
;	COMDAT xdata$x
; File c:\offi src_real\offi src!\_common\file.h
xdata$x	SEGMENT
$T148503 DD	0ffffffffH
	DD	FLAT:$L148458
$T148500 DD	019930520H
	DD	01H
	DD	FLAT:$T148503
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MAKCNCEN@CTarga?3?3Load?5Failed?5?$DN?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BJ@MAKCNCEN@CTarga?3?3Load?5Failed?5?$DN?5?$CFs?$AA@ DB 'CTarga::L'
	DB	'oad Failed = %s', 00H			; `string'
; Function compile flags: /Ogty
; File c:\offi src_real\offi src!\_common\targa.cpp
CONST	ENDS
;	COMDAT ?Load@CTarga@@QAEHPBDPAPAEPAUtagSIZE@@@Z
_TEXT	SEGMENT
_file$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_ppPal$ = 8						; size = 4
_lpszFileName$ = 8					; size = 4
_lppData$ = 12						; size = 4
_pSize$ = 16						; size = 4
?Load@CTarga@@QAEHPBDPAPAEPAUtagSIZE@@@Z PROC NEAR	; CTarga::Load, COMDAT
; _this$ = ecx

; 27   : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?Load@CTarga@@QAEHPBDPAPAEPAUtagSIZE@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 08	 sub	 esp, 8
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi

; 28   : 	CResFile file;

  0001b	bd 00 00 00 00	 mov	 ebp, OFFSET FLAT:??_7CFileIO@@6B@
  00020	33 db		 xor	 ebx, ebx
  00022	57		 push	 edi
  00023	8b f1		 mov	 esi, ecx
  00025	89 6c 24 10	 mov	 DWORD PTR _file$[esp+36], ebp
  00029	89 5c 24 14	 mov	 DWORD PTR _file$[esp+40], ebx

; 29   : 	if( !file.Open( lpszFileName, "rb" ) )

  0002d	8b 7c 24 28	 mov	 edi, DWORD PTR _lpszFileName$[esp+32]
  00031	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02JDPG@rb?$AA@
  00036	57		 push	 edi
  00037	8d 4c 24 18	 lea	 ecx, DWORD PTR _file$[esp+44]
  0003b	89 5c 24 28	 mov	 DWORD PTR __$EHRec$[esp+52], ebx
  0003f	e8 00 00 00 00	 call	 ?Open@CFileIO@@UAEHPBDPAD@Z ; CFileIO::Open
  00044	85 c0		 test	 eax, eax
  00046	75 3a		 jne	 SHORT $L147949

; 30   : 	{
; 31   : 		Error( "CTarga::Load Failed = %s", lpszFileName );

  00048	57		 push	 edi
  00049	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@MAKCNCEN@CTarga?3?3Load?5Failed?5?$DN?5?$CFs?$AA@
  0004e	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00053	83 c4 08	 add	 esp, 8

; 32   : 		return FALSE;

  00056	8d 4c 24 10	 lea	 ecx, DWORD PTR _file$[esp+36]
  0005a	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+44], -1
  00062	89 6c 24 10	 mov	 DWORD PTR _file$[esp+36], ebp
  00066	e8 00 00 00 00	 call	 ?Close@CFileIO@@UAEHXZ	; CFileIO::Close
  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5d		 pop	 ebp
  0006e	33 c0		 xor	 eax, eax
  00070	5b		 pop	 ebx

; 69   : }

  00071	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  00075	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007c	83 c4 14	 add	 esp, 20			; 00000014H
  0007f	c2 0c 00	 ret	 12			; 0000000cH
$L147949:

; 33   : 	}
; 34   : 	m_nFileSize  = file.GetLength();

  00082	8b 44 24 14	 mov	 eax, DWORD PTR _file$[esp+40]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _fileno
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 __filelength

; 35   : 	m_pBuf = new BYTE[m_nFileSize];

  00092	50		 push	 eax
  00093	89 46 28	 mov	 DWORD PTR [esi+40], eax
  00096	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 36   : 
; 37   : 	file.Read( m_pBuf, m_nFileSize, 1 );

  0009b	8b 54 24 20	 mov	 edx, DWORD PTR _file$[esp+52]
  0009f	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  000a2	52		 push	 edx
  000a3	6a 01		 push	 1
  000a5	51		 push	 ecx
  000a6	50		 push	 eax
  000a7	89 46 24	 mov	 DWORD PTR [esi+36], eax
  000aa	e8 00 00 00 00	 call	 _fread

; 38   : 
; 39   : 	DWORD * ppPal;
; 40   : 	int pDestBPP = 0;
; 41   : 	m_nTgaDataIdx = 0; 
; 42   : 	m_nReadPixelCount = 0;
; 43   : 	DoDecode((DWORD**)&ppPal,&pDestBPP,(char*)m_pBuf);

  000af	8b 6e 24	 mov	 ebp, DWORD PTR [esi+36]
  000b2	83 c4 1c	 add	 esp, 28			; 0000001cH
  000b5	55		 push	 ebp
  000b6	56		 push	 esi
  000b7	8b ce		 mov	 ecx, esi
  000b9	89 5e 2c	 mov	 DWORD PTR [esi+44], ebx
  000bc	89 5e 30	 mov	 DWORD PTR [esi+48], ebx
  000bf	e8 00 00 00 00	 call	 ?readTgaHeader@CTarga@@AAEXPAU_TgaHeader@@PAD@Z ; CTarga::readTgaHeader
  000c4	8a 4e 1c	 mov	 cl, BYTE PTR [esi+28]
  000c7	b0 08		 mov	 al, 8
  000c9	3a c1		 cmp	 al, cl
  000cb	8a 46 01	 mov	 al, BYTE PTR [esi+1]
  000ce	1b ff		 sbb	 edi, edi
  000d0	83 e7 18	 and	 edi, 24			; 00000018H
  000d3	83 c7 08	 add	 edi, 8
  000d6	3a c3		 cmp	 al, bl
  000d8	74 1b		 je	 SHORT $L148486
  000da	0f b6 56 0b	 movzx	 edx, BYTE PTR [esi+11]
  000de	8b 46 07	 mov	 eax, DWORD PTR [esi+7]
  000e1	55		 push	 ebp
  000e2	57		 push	 edi
  000e3	8d 4c 24 30	 lea	 ecx, DWORD PTR _ppPal$[esp+40]
  000e7	51		 push	 ecx
  000e8	8b 4e 03	 mov	 ecx, DWORD PTR [esi+3]
  000eb	52		 push	 edx
  000ec	50		 push	 eax
  000ed	51		 push	 ecx
  000ee	8b ce		 mov	 ecx, esi
  000f0	e8 00 00 00 00	 call	 ?readPalette@CTarga@@AAEXHHHPAPAKHPAD@Z ; CTarga::readPalette
$L148486:

; 44   : 	/*
; 45   : 	if(pPal != NULL && m_header.CmapType != 0) 
; 46   : 	{
; 47   : 		RGBQUAD rgb[256];
; 48   : 		for(int i = 0; i < 256; i++)
; 49   : 		{
; 50   : 			rgb[i].rgbRed   = (ppPal)[i] & 0x00ff0000;
; 51   : 			rgb[i].rgbGreen = (ppPal)[i] & 0x0000ff00;
; 52   : 			rgb[i].rgbBlue  = (ppPal)[i] & 0x000000ff;
; 53   : 		}
; 54   : 		pPal->CreateIdPalette(rgb);
; 55   : 	}
; 56   : 	else pPal = NULL;
; 57   : 	*/
; 58   : 	//CreateDIBSection(pDc,pPal,m_header.ImageWidth,-m_header.ImageHeight,pDestBPP);	
; 59   : 	m_pData = new BYTE[ m_header.ImageWidth * m_header.ImageHeight * 4];

  000f5	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  000f8	0f af 56 18	 imul	 edx, DWORD PTR [esi+24]
  000fc	c1 e2 02	 shl	 edx, 2
  000ff	52		 push	 edx
  00100	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 60   : 	pSize->cx = m_header.ImageWidth;

  00105	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00108	89 46 20	 mov	 DWORD PTR [esi+32], eax
  0010b	8b 44 24 34	 mov	 eax, DWORD PTR _pSize$[esp+36]
  0010f	89 08		 mov	 DWORD PTR [eax], ecx

; 61   : 	pSize->cy = m_header.ImageHeight;

  00111	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00114	83 c4 04	 add	 esp, 4
  00117	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 62   : 	readImage (&m_header,(DWORD**)&ppPal, pDestBPP,(char*)m_pBuf);

  0011a	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0011d	50		 push	 eax
  0011e	57		 push	 edi
  0011f	8d 4c 24 30	 lea	 ecx, DWORD PTR _ppPal$[esp+40]
  00123	51		 push	 ecx
  00124	56		 push	 esi
  00125	8b ce		 mov	 ecx, esi
  00127	e8 00 00 00 00	 call	 ?readImage@CTarga@@AAEXPAU_TgaHeader@@PAPAKHPAD@Z ; CTarga::readImage

; 63   : 	//DecodeBitmap(m_pData,m_pBuf+sizeof(m_header),GetWidth()-m_header.x2);
; 64   : 	//DecodeBitmap(m_pData,m_pBuf+sizeof(m_header),m_header.ImageWidth-m_header.x2);
; 65   : 	*lppData = m_pData;

  0012c	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  0012f	8b 44 24 2c	 mov	 eax, DWORD PTR _lppData$[esp+32]
  00133	89 10		 mov	 DWORD PTR [eax], edx

; 66   : 	FreeBuffer();

  00135	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00138	50		 push	 eax
  00139	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0013e	83 c4 04	 add	 esp, 4

; 67   : 	
; 68   : 	return TRUE;

  00141	8d 4c 24 10	 lea	 ecx, DWORD PTR _file$[esp+36]
  00145	89 5e 24	 mov	 DWORD PTR [esi+36], ebx
  00148	89 5e 20	 mov	 DWORD PTR [esi+32], ebx
  0014b	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+44], -1
  00153	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR _file$[esp+36], OFFSET FLAT:??_7CFileIO@@6B@
  0015b	e8 00 00 00 00	 call	 ?Close@CFileIO@@UAEHXZ	; CFileIO::Close

; 69   : }

  00160	8b 4c 24 18	 mov	 ecx, DWORD PTR __$EHRec$[esp+36]
  00164	5f		 pop	 edi
  00165	5e		 pop	 esi
  00166	5d		 pop	 ebp
  00167	b8 01 00 00 00	 mov	 eax, 1
  0016c	5b		 pop	 ebx
  0016d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00174	83 c4 14	 add	 esp, 20			; 00000014H
  00177	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L148458:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR _file$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CFileIO@@UAE@XZ	; CFileIO::~CFileIO
__ehhandler$?Load@CTarga@@QAEHPBDPAPAEPAUtagSIZE@@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T148500
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Load@CTarga@@QAEHPBDPAPAEPAUtagSIZE@@@Z ENDP		; CTarga::Load
END
