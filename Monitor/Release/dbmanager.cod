; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\dbmanager.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??0CDbManager@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CDbManager@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteLogofServerDown@CDbManager@@QAEHKAAVCTime@ATL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E1
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT _$E2
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??0CDbManager@@QAE@XZ				; CDbManager::CDbManager
; Function compile flags: /Ogty
; File c:\offi src_real\offi src!\monitor\dbmanager.cpp
;	COMDAT ??0CDbManager@@QAE@XZ
_TEXT	SEGMENT
??0CDbManager@@QAE@XZ PROC NEAR				; CDbManager::CDbManager, COMDAT
; _this$ = ecx

; 11   : {

  00000	8b c1		 mov	 eax, ecx

; 12   : //	if( FALSE == m_qry.Connect( 3, DSN_NAME, DB_ADMIN_ID, DB_ADMIN_PASS ) )
; 13   : //	{
; 14   : //		ASSERT( 0 );
; 15   : //	}
; 16   : 
; 17   : #ifdef __DB_CHECK
; 18   : 	if( m_Lua.RunScript( "DBCheck.lua" ) != 0 )
; 19   : 	{
; 20   : 		AfxMessageBox( "DBCheck.lua Run Failed!!!" );
; 21   : 		exit(0);
; 22   : 	}
; 23   : 	
; 24   : 	m_Lua.GetGloabal( "tDB" );
; 25   : 	m_Lua.PushNil();
; 26   : 	
; 27   : 	char *strDSN, *strID, strPWD[256] = {0,};
; 28   : 	string	strQuery;
; 29   : 	for( int i=0; m_Lua.TableLoop( -2 ); i++ )
; 30   : 	{
; 31   : 		CQuery* pQuery = new CQuery;
; 32   : 		m_vecpQry.push_back(pQuery);
; 33   : 		
; 34   : 		strDSN	= const_cast<char*>(m_Lua.GetFieldToString( -1, "DSN_NAME" ));
; 35   : 		strID	= const_cast<char*>(m_Lua.GetFieldToString( -1, "DB_ADMIN_ID" ));
; 36   : 		::GetPWDFromToken( m_Lua.GetFieldToString( -1, "DB_PWD" ), strPWD );
; 37   : 		strQuery = m_Lua.GetFieldToString( -1, "QUERY" );
; 38   : 		m_vecstrQry.push_back(strQuery);
; 39   : 		if( m_vecpQry[i]->Connect( 3, strDSN, strID, strPWD ) == FALSE )
; 40   : 		{
; 41   : 			AfxMessageBox( "DB Connect Failed!!!" );
; 42   : 			exit(0);
; 43   : 		}
; 44   : 
; 45   : 		m_Lua.Pop(1);
; 46   : 	}
; 47   : 	m_Lua.Pop(0);
; 48   : 
; 49   : 	CheckDB();	// 시험 삼아 한번 체크 한다.
; 50   : #endif // __DB_CHECK
; 51   : }

  00002	c3		 ret	 0
??0CDbManager@@QAE@XZ ENDP				; CDbManager::CDbManager
_TEXT	ENDS
PUBLIC	??1CDbManager@@QAE@XZ				; CDbManager::~CDbManager
; Function compile flags: /Ogty
;	COMDAT ??1CDbManager@@QAE@XZ
_TEXT	SEGMENT
??1CDbManager@@QAE@XZ PROC NEAR				; CDbManager::~CDbManager, COMDAT
; _this$ = ecx

; 55   : //	m_qry.DisConnect();
; 56   : #ifdef __DB_CHECK
; 57   : 	for( int i=0; i<m_vecpQry.size(); i++ )
; 58   : 	{
; 59   : 		m_vecpQry[i]->DisConnect();
; 60   : 		safe_delete( m_vecpQry[i] );
; 61   : 	}
; 62   : #endif // __DB_CHECK
; 63   : }

  00000	c3		 ret	 0
??1CDbManager@@QAE@XZ ENDP				; CDbManager::~CDbManager
_TEXT	ENDS
PUBLIC	?WriteLogofServerDown@CDbManager@@QAEHKAAVCTime@ATL@@@Z ; CDbManager::WriteLogofServerDown
; Function compile flags: /Ogty
;	COMDAT ?WriteLogofServerDown@CDbManager@@QAEHKAAVCTime@ATL@@@Z
_TEXT	SEGMENT
_dwId$ = 8						; size = 4
_tm$ = 12						; size = 4
?WriteLogofServerDown@CDbManager@@QAEHKAAVCTime@ATL@@@Z PROC NEAR ; CDbManager::WriteLogofServerDown, COMDAT
; _this$ = ecx

; 67   : /*
; 68   : 	CTime tmCur	= CTime::GetCurrentTime();
; 69   : 	CString sStart, sEnd;
; 70   : 
; 71   : 	sStart	= tm.Format( "%Y%m%d%H%M%S" );
; 72   : 	sEnd	= tmCur.Format( "%Y%m%d%H%M%S" );
; 73   : 
; 74   : 	char sQuery[128]	= { 0, };
; 75   : 	sprintf( sQuery, "AeonServerDown %d, '%s', '%s'", dwId, sStart, sEnd );
; 76   : 
; 77   : 	if( FALSE == m_qry.Exec( sQuery ) )
; 78   : 		return FALSE;
; 79   : 
; 80   : 	m_qry.Clear();
; 81   : */
; 82   : 	return TRUE;

  00000	b8 01 00 00 00	 mov	 eax, 1

; 83   : }

  00005	c2 08 00	 ret	 8
?WriteLogofServerDown@CDbManager@@QAEHKAAVCTime@ATL@@@Z ENDP ; CDbManager::WriteLogofServerDown
_TEXT	ENDS
EXTRN	_atexit:NEAR
CRT$XCU	SEGMENT
_$S3	DD	FLAT:_$E1
; Function compile flags: /Ogty
CRT$XCU	ENDS
;	COMDAT _$E1
text$yc	SEGMENT
_$E1	PROC NEAR					; COMDAT

; 147  : CDbManager	g_DbManager;

  00000	68 00 00 00 00	 push	 OFFSET FLAT:_$E2
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
_$E1	ENDP
; Function compile flags: /Ogty
text$yc	ENDS
;	COMDAT _$E2
text$yd	SEGMENT
_$E2	PROC NEAR					; COMDAT
  00000	c3		 ret	 0
_$E2	ENDP
text$yd	ENDS
PUBLIC	?g_DbManager@@3VCDbManager@@A			; g_DbManager
_BSS	SEGMENT
?g_DbManager@@3VCDbManager@@A DB 01H DUP (?)		; g_DbManager
_BSS	ENDS
END
